{"seed":2726446763,"processedDockerfileHash":"c331e1aacf2ecc8c747d36b3f7d6e96e","fixedSmells":["use-no-install-recommends","do-not-use-apt-get-update-alone","pin-package-manager-versions-apt-get","pin-package-manager-versions-pip","pin-package-manager-versions-npm","pin-package-manager-versions-gem","pin-package-manager-versions-apk","use-copy-instead-of-add","use-wget-instead-of-add","do-not-have-secrets","have-a-healthcheck","have-a-user"],"successfullyFixedSmells":["pin-package-manager-versions-npm","pin-package-manager-versions-apk","use-copy-instead-of-add","have-a-healthcheck","have-a-user"],"processedDockerfile":"#   Copyright © 2018-2019 Stanislav Valasek <valasek@gmail.com>\n#   Accept the Go version for the image to be set as a build argument.\n#   Default to Go 1.12\nARG GO_VERSION=1.12\n#  ##########################################\n#   First stage: build the backend executable.\n#   FROM golang:${GO_VERSION}-alpine AS builder\nFROM golang:alpine AS backend\n#   Create the user and group files that will be used in the running container to\n#   run the process as an unprivileged user.\nRUN mkdir /user \\\n && echo 'nobody:x:65534:65534:nobody:/:' > /user/passwd \\\n && echo 'nobody:x:65534:' > /user/group\n#   Install the Certificate-Authority certificates for the app to be able to make\n#   calls to HTTPS endpoints.\n#   Git is required for fetching the dependencies.\nRUN apk add ca-certificates=20220614-r4 git=2.38.4-r1 --no-cache\n#   Set the working directory outside $GOPATH to enable the support for modules.\nWORKDIR /src\n#   Fetch dependencies first; they are less susceptible to change on every build\n#   and will therefore be cached for speeding up the next build\nCOPY ./server/go.mod ./go.mod\nRUN go mod download\nCOPY ./server/data/ /data\nRUN chmod -R ug+rw /data\nCOPY ./server/documentation/ /documentation\nCOPY ./server/documentation/ /documentation/statics\nRUN chmod -R ug+rw /documentation\nCOPY ./server/logs/ /logs\nRUN chmod -R ug+rwx /logs\nCOPY ./docker-entrypoint.sh /docker-entrypoint.sh\nCOPY ./server/timesheet-dataarch.yaml /timesheet.yaml\nRUN chmod +x /docker-entrypoint.sh\n#   Import the code from the context.\nCOPY ./server/ ./\n#   Build the executable to `/app`. Mark the build as statically linked.\n#   RUN GOOS=linux GOARCH=amd64 go build -ldflags=\"-w -s\" CGO_ENABLED=0 \\\n#       -installsuffix 'static' \\\n#       -o /app .\nRUN GOOS=linux GOARCH=amd64 CGO_ENABLED=0 go build -ldflags \"-X github.com/valasek/timesheet/server/version.Version=1.4.0\" -installsuffix 'static' -o /timesheet.bin .\n#   RUN ls -la .\n#  #############################################\n#   Second stage: build the frontend executable.\nFROM node:lts-alpine AS frontend\n#   fix due to optipng-bin in icon-factory - https://github.com/imagemin/optipng-bin/issues/84\nRUN apk add pkgconfig autoconf=2.71-r1 automake=1.16.5-r1 libtool=2.4.7-r1 nasm=2.15.05-r1 build-base=0.5-r3 zlib-dev=1.2.13-r0 --no-cache\n#   make the 'client' folder the current working directory\nWORKDIR /client\n#   copy both 'package.json' and 'package-lock.json' (if available)\nCOPY ./client/package*.json ./\nCOPY ./client/ ./\n#   install project dependencies\nRUN npm install\nRUN npm install @quasar/cli -g\nRUN quasar upgrade -i\n#   copy project files and folders to the current working directory (i.e. 'app' folder)\nCOPY ./client ./\n#   build app for production with minification\nRUN npm run build-da\n#   RUN ls -la ./\n#   RUN ls -la ./dist\n#   RUN chmod -R ug+rw ./dist\n#   EXPOSE 8080\n#   CMD [ \"http-server\", \"dist\" ]\n#  ####################################\n#   Final stage: the running container.\n#   FROM scratch AS final\nFROM alpine AS final\n#   Import the user and group files from the first stage.\nCOPY --from=backend /user/group /user/passwd /etc/\n#   Import the Certificate-Authority certificates for enabling HTTPS.\nCOPY --from=backend /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/\n#   Import the compiled executable from the first stage.\nCOPY --from=backend /timesheet.bin /timesheet.bin\n#   Copy data folder\nCOPY --from=backend /data /data\n#   Copy documentation folder\nCOPY --from=backend /documentation /documentation\n#   Copy log folder\nCOPY --from=backend /logs /logs\n#   Copy compiled frontend files\nCOPY --from=frontend /client/dist/spa /client/dist\n#   Declare the port on which the webbackend will be exposed.\n#   As we're going to run the executable as an unprivileged user, we can't bind\n#   to ports below 1024.\n#   Expose is NOT supported by Heroku\n#   EXPOSE 3000\n#   Perform any further action as an unprivileged user.\n#   USER nobody:nobody\nCOPY --from=backend /docker-entrypoint.sh /docker-entrypoint.sh\nCOPY --from=backend /timesheet.yaml /timesheet.yaml\n#   Run the compiled binary.\nENTRYPOINT [\"/docker-entrypoint.sh\"]\nCMD [\"/docker-entrypoint.sh\", \"--debug=5\"]\nRUN addgroup -S docker-user ; adduser -S -G docker-user docker-user\nUSER docker-user\n# Please add your HEALTHCHECK here!!!\n","originalDockerfile":"#  Copyright © 2018-2019 Stanislav Valasek <valasek@gmail.com>\n#  Accept the Go version for the image to be set as a build argument.\n#  Default to Go 1.12\nARG GO_VERSION=1.12\n# ##########################################\n#  First stage: build the backend executable.\n#  FROM golang:${GO_VERSION}-alpine AS builder\nFROM golang:alpine AS backend\n#  Create the user and group files that will be used in the running container to\n#  run the process as an unprivileged user.\nRUN mkdir /user \\\n && echo 'nobody:x:65534:65534:nobody:/:' > /user/passwd \\\n && echo 'nobody:x:65534:' > /user/group\n#  Install the Certificate-Authority certificates for the app to be able to make\n#  calls to HTTPS endpoints.\n#  Git is required for fetching the dependencies.\nRUN apk add --no-cache ca-certificates git\n#  Set the working directory outside $GOPATH to enable the support for modules.\nWORKDIR /src\n#  Fetch dependencies first; they are less susceptible to change on every build\n#  and will therefore be cached for speeding up the next build\nCOPY ./server/go.mod ./go.mod\nRUN go mod download\nADD ./server/data/ /data\nRUN chmod -R ug+rw /data\nADD ./server/documentation/ /documentation\nADD ./server/documentation/ /documentation/statics\nRUN chmod -R ug+rw /documentation\nADD ./server/logs/ /logs\nRUN chmod -R ug+rwx /logs\nCOPY ./docker-entrypoint.sh /docker-entrypoint.sh\nCOPY ./server/timesheet-dataarch.yaml /timesheet.yaml\nRUN chmod +x /docker-entrypoint.sh\n#  Import the code from the context.\nCOPY ./server/ ./\n#  Build the executable to `/app`. Mark the build as statically linked.\n#  RUN GOOS=linux GOARCH=amd64 go build -ldflags=\"-w -s\" CGO_ENABLED=0 \\\n#      -installsuffix 'static' \\\n#      -o /app .\nRUN GOOS=linux GOARCH=amd64 CGO_ENABLED=0 go build -ldflags \"-X github.com/valasek/timesheet/server/version.Version=1.4.0\" -installsuffix 'static' -o /timesheet.bin .\n#  RUN ls -la .\n# #############################################\n#  Second stage: build the frontend executable.\nFROM node:lts-alpine AS frontend\n#  fix due to optipng-bin in icon-factory - https://github.com/imagemin/optipng-bin/issues/84\nRUN apk --no-cache add pkgconfig autoconf automake libtool nasm build-base zlib-dev\n#  make the 'client' folder the current working directory\nWORKDIR /client\n#  copy both 'package.json' and 'package-lock.json' (if available)\nCOPY ./client/package*.json ./\nCOPY ./client/ ./\n#  install project dependencies\nRUN npm install\nRUN npm install @quasar/cli -g\nRUN quasar upgrade -i\n#  copy project files and folders to the current working directory (i.e. 'app' folder)\nCOPY ./client ./\n#  build app for production with minification\nRUN npm run build-da\n#  RUN ls -la ./\n#  RUN ls -la ./dist\n#  RUN chmod -R ug+rw ./dist\n#  EXPOSE 8080\n#  CMD [ \"http-server\", \"dist\" ]\n# ####################################\n#  Final stage: the running container.\n#  FROM scratch AS final\nFROM alpine AS final\n#  Import the user and group files from the first stage.\nCOPY --from=backend /user/group /user/passwd /etc/\n#  Import the Certificate-Authority certificates for enabling HTTPS.\nCOPY --from=backend /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/\n#  Import the compiled executable from the first stage.\nCOPY --from=backend /timesheet.bin /timesheet.bin\n#  Copy data folder\nCOPY --from=backend /data /data\n#  Copy documentation folder\nCOPY --from=backend /documentation /documentation\n#  Copy log folder\nCOPY --from=backend /logs /logs\n#  Copy compiled frontend files\nCOPY --from=frontend /client/dist/spa /client/dist\n#  Declare the port on which the webbackend will be exposed.\n#  As we're going to run the executable as an unprivileged user, we can't bind\n#  to ports below 1024.\n#  Expose is NOT supported by Heroku\n#  EXPOSE 3000\n#  Perform any further action as an unprivileged user.\n#  USER nobody:nobody\nCOPY --from=backend /docker-entrypoint.sh /docker-entrypoint.sh\nCOPY --from=backend /timesheet.yaml /timesheet.yaml\n#  Run the compiled binary.\nENTRYPOINT [\"/docker-entrypoint.sh\"]\nCMD [\"/docker-entrypoint.sh\", \"--debug=5\"]\n","injectedSmells":[],"originalDockerfileHash":"18bed48c51c4bb5f3a909a63a28246ab","successfullyInjectedSmells":[],"originalDockerfileUglified":"#   Copyright © 2018-2019 Stanislav Valasek <valasek@gmail.com>\n#   Accept the Go version for the image to be set as a build argument.\n#   Default to Go 1.12\nARG GO_VERSION=1.12\n#  ##########################################\n#   First stage: build the backend executable.\n#   FROM golang:${GO_VERSION}-alpine AS builder\nFROM golang:alpine AS backend\n#   Create the user and group files that will be used in the running container to\n#   run the process as an unprivileged user.\nRUN mkdir /user \\\n && echo 'nobody:x:65534:65534:nobody:/:' > /user/passwd \\\n && echo 'nobody:x:65534:' > /user/group\n#   Install the Certificate-Authority certificates for the app to be able to make\n#   calls to HTTPS endpoints.\n#   Git is required for fetching the dependencies.\nRUN apk add --no-cache ca-certificates git\n#   Set the working directory outside $GOPATH to enable the support for modules.\nWORKDIR /src\n#   Fetch dependencies first; they are less susceptible to change on every build\n#   and will therefore be cached for speeding up the next build\nCOPY ./server/go.mod ./go.mod\nRUN go mod download\nADD ./server/data/ /data\nRUN chmod -R ug+rw /data\nADD ./server/documentation/ /documentation\nADD ./server/documentation/ /documentation/statics\nRUN chmod -R ug+rw /documentation\nADD ./server/logs/ /logs\nRUN chmod -R ug+rwx /logs\nCOPY ./docker-entrypoint.sh /docker-entrypoint.sh\nCOPY ./server/timesheet-dataarch.yaml /timesheet.yaml\nRUN chmod +x /docker-entrypoint.sh\n#   Import the code from the context.\nCOPY ./server/ ./\n#   Build the executable to `/app`. Mark the build as statically linked.\n#   RUN GOOS=linux GOARCH=amd64 go build -ldflags=\"-w -s\" CGO_ENABLED=0 \\\n#       -installsuffix 'static' \\\n#       -o /app .\nRUN GOOS=linux GOARCH=amd64 CGO_ENABLED=0 go build -ldflags \"-X github.com/valasek/timesheet/server/version.Version=1.4.0\" -installsuffix 'static' -o /timesheet.bin .\n#   RUN ls -la .\n#  #############################################\n#   Second stage: build the frontend executable.\nFROM node:lts-alpine AS frontend\n#   fix due to optipng-bin in icon-factory - https://github.com/imagemin/optipng-bin/issues/84\nRUN apk --no-cache add pkgconfig autoconf automake libtool nasm build-base zlib-dev\n#   make the 'client' folder the current working directory\nWORKDIR /client\n#   copy both 'package.json' and 'package-lock.json' (if available)\nCOPY ./client/package*.json ./\nCOPY ./client/ ./\n#   install project dependencies\nRUN npm install\nRUN npm install @quasar/cli -g\nRUN quasar upgrade -i\n#   copy project files and folders to the current working directory (i.e. 'app' folder)\nCOPY ./client ./\n#   build app for production with minification\nRUN npm run build-da\n#   RUN ls -la ./\n#   RUN ls -la ./dist\n#   RUN chmod -R ug+rw ./dist\n#   EXPOSE 8080\n#   CMD [ \"http-server\", \"dist\" ]\n#  ####################################\n#   Final stage: the running container.\n#   FROM scratch AS final\nFROM alpine AS final\n#   Import the user and group files from the first stage.\nCOPY --from=backend /user/group /user/passwd /etc/\n#   Import the Certificate-Authority certificates for enabling HTTPS.\nCOPY --from=backend /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/\n#   Import the compiled executable from the first stage.\nCOPY --from=backend /timesheet.bin /timesheet.bin\n#   Copy data folder\nCOPY --from=backend /data /data\n#   Copy documentation folder\nCOPY --from=backend /documentation /documentation\n#   Copy log folder\nCOPY --from=backend /logs /logs\n#   Copy compiled frontend files\nCOPY --from=frontend /client/dist/spa /client/dist\n#   Declare the port on which the webbackend will be exposed.\n#   As we're going to run the executable as an unprivileged user, we can't bind\n#   to ports below 1024.\n#   Expose is NOT supported by Heroku\n#   EXPOSE 3000\n#   Perform any further action as an unprivileged user.\n#   USER nobody:nobody\nCOPY --from=backend /docker-entrypoint.sh /docker-entrypoint.sh\nCOPY --from=backend /timesheet.yaml /timesheet.yaml\n#   Run the compiled binary.\nENTRYPOINT [\"/docker-entrypoint.sh\"]\nCMD [\"/docker-entrypoint.sh\", \"--debug=5\"]\n","originalDockerfileUglifiedHash":"49d59d2e78ebf1f33f570431fdcea28b","fileName":"/ICSME-replicationpackage/dataset/smelly_dockerfiles_bianncle/d30b2730bb746f4215aeac615072a858dd002e56.dockerfile"}