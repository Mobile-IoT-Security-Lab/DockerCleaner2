{"seed":2223760647,"processedDockerfileHash":"43c856db35c1f2effe520f1c27a36e02","fixedSmells":["use-no-install-recommends","do-not-use-apt-get-update-alone","pin-package-manager-versions-apt-get","pin-package-manager-versions-pip","pin-package-manager-versions-npm","pin-package-manager-versions-gem","pin-package-manager-versions-apk","use-copy-instead-of-add","use-wget-instead-of-add","do-not-have-secrets","have-a-healthcheck","have-a-user"],"successfullyFixedSmells":["have-a-healthcheck"],"processedDockerfile":"#   Build on Docker's official CentOS 7 image.\nFROM centos:7\n#   Expose the port that `manage.py runserver` uses by default.\nEXPOSE 8000/tcp\n#   Put the Python source code here.\nWORKDIR /usr/src/app\n#   Set up the locale. Lots of things depend on this.\nENV LANG=\"en_US.UTF-8\"\nENV LC_ALL=\"en_US.UTF-8\"\nENV LANGUAGE=\"en_US:en\"\n#   Install required system packages.\n#   git2u: git 2 or later is required for our use of GIT_SSH_COMMAND in AppSourceConnection\n#   jq: we use it to assemble the local/environment.json file\nRUN yum -y install https://centos7.iuscommunity.org/ius-release.rpm \\\n && yum -y update \\\n && yum -y install python36u python36u-devel.x86_64 python36u-pip gcc-c++.x86_64 unzip git2u jq nmap-ncat graphviz pandoc xorg-x11-server-Xvfb wkhtmltopdf supervisor mysql-devel \\\n && yum clean all \\\n && rm -rf /var/cache/yum\n#   Copy in the Python module requirements and install them.\n#   Manually install database drivers which aren't in our requirements\n#   file because they're not commonly used in development.\nCOPY requirements.txt ./\nCOPY requirements_mysql.txt ./\nRUN pip3.6 install --no-cache-dir -r requirements.txt\nRUN pip3.6 install --no-cache-dir -r requirements_mysql.txt\n#   Run pyup.io's python package vulnerability check.\nRUN safety check\n#   Copy in the vendor resources and fetch them.\nCOPY fetch-vendor-resources.sh ./\nRUN ./fetch-vendor-resources.sh\n#   Copy in remaining source code. (We put this last because these\n#   change most frequently, so there is less to rebuild if we put\n#   infrequently changed steps above.)\n#\n#   NOTE: Do *not* include the \"local\" directory in this step, since\n#   that often has local development files. But *do* include fixtures\n#   so that tests can be run.\nCOPY VERSION ./VERSION\nCOPY discussion ./discussion\nCOPY guidedmodules ./guidedmodules\nCOPY modules ./modules\nCOPY siteapp ./siteapp\nCOPY templates ./templates\nCOPY fixtures ./fixtures\nCOPY testmocking ./testmocking\nCOPY manage.py .\n#   Flatten static files. Create a local/environment.json file that\n#   has the static directory set and only setting necessary for collectstatic\n#   to work. It matches what's set in dockerfile_exec.sh.\nRUN mkdir -p local \\\n && echo '{ \"static\": \"static_root\", \"debug\": false, \"host\": \"_\", \"https\": false }' > local/environment.json\nRUN python3.6 manage.py collectstatic --noinput\n#   Configure supervisord.\n#   a) Wipe out /var/{run,log} because when these directories are mounted with\n#      tmpfs they will be empty, so start them empty so the two setups match.\n#   b) Make /var/{run,log} world-writable because when we start the container with\n#      the non-root user it will need permission to write there.\n#   c) Move the supervisor log from /var/log/supervisor and the child process logs\n#      from /tmp to /var/log to make them all easily accessible if /var/log is mounted\n#      to a volume, and similarly the run socket from /var/run/supervisor.\n#      Otherwise we have to mess with file permissions so the inner directories are\n#      writable, and I couldn't get that to work. Even if the directories had chmod 777\n#      the non-root user could not create files inside them.\nRUN rm -rf /run/* /var/log/*\nRUN chmod a+rwx /run /var/log\nRUN sed -i \"s:/var/run/supervisor/:/var/run/:\" /etc/supervisord.conf\nRUN sed -i \"s:/var/log/supervisor/:/var/log/:\" /etc/supervisord.conf\nRUN sed -i \"s:^;childlogdir=/tmp:childlogdir=/var/log:\" /etc/supervisord.conf\nCOPY deployment/docker/supervisord.ini /etc/supervisord.d/application.ini\n#   Add container startup and management scripts.\nCOPY deployment/docker/dockerfile_exec.sh .\nCOPY deployment/docker/first_run.sh /usr/local/bin/first_run\nCOPY deployment/docker/uwsgi_stats.sh /usr/local/bin/uwsgi_stats\nCOPY deployment/docker/tail_logs.sh /usr/local/bin/tail_logs\n#   This directory must be present for the AppSource created by our\n#   first_run script. The directory only has something in it if\n#   the container is launched with --mount.\nRUN mkdir -p /mnt/apps\n#   Create a non-root user and group for the application to run as to guard against\n#   run-time modification of the system and application.\nRUN groupadd application \\\n && useradd -g application -d /home/application -s /sbin/nologin -c \"application process\" application \\\n && chown -R application:application /home/application\nRUN echo -n \"the non-root user is: \" \\\n && grep ^application /etc/passwd\n#   Give the non-root user access to scratch space.\nRUN mkdir -p local\nRUN chown -R application:application local\n#   Move the environment.json to /tmp because in some environments the main\n#   filesystem is read-only and we won't be able to update local/environment.json\n#   once the container starts. In those cases, /tmp must be a tmpfs. We use\n#   /tmp for other purposes at run-time as well. Although we don't need a\n#   working environment.json file for the remainder of this Dockerfile, downstream\n#   packagers using 'FROM govready/govready-q' might want to run additional\n#   management commands, so we'll keep it working.\nRUN cp local/environment.json /tmp\nRUN chown -R application:application /tmp/environment.json\nRUN ln -sf /tmp/environment.json local/environment.json\n#   Run the container's process zero as this user.\nUSER application\n#   Test.\nRUN python3.6 manage.py check\n#   Set the startup script.\nCMD [\"bash\", \"dockerfile_exec.sh\"]\n# Please add your HEALTHCHECK here!!!\n","originalDockerfile":"#  Build on Docker's official CentOS 7 image.\nFROM centos:7\n#  Expose the port that `manage.py runserver` uses by default.\nEXPOSE 8000/tcp\n#  Put the Python source code here.\nWORKDIR /usr/src/app\n#  Set up the locale. Lots of things depend on this.\nENV LANG=\"en_US.UTF-8\"\nENV LC_ALL=\"en_US.UTF-8\"\nENV LANGUAGE=\"en_US:en\"\n#  Install required system packages.\n#  git2u: git 2 or later is required for our use of GIT_SSH_COMMAND in AppSourceConnection\n#  jq: we use it to assemble the local/environment.json file\nRUN yum -y install https://centos7.iuscommunity.org/ius-release.rpm \\\n && yum -y update \\\n && yum -y install python36u python36u-devel.x86_64 python36u-pip gcc-c++.x86_64 unzip git2u jq nmap-ncat graphviz pandoc xorg-x11-server-Xvfb wkhtmltopdf supervisor mysql-devel \\\n && yum clean all \\\n && rm -rf /var/cache/yum\n#  Copy in the Python module requirements and install them.\n#  Manually install database drivers which aren't in our requirements\n#  file because they're not commonly used in development.\nCOPY requirements.txt ./\nCOPY requirements_mysql.txt ./\nRUN pip3.6 install --no-cache-dir -r requirements.txt\nRUN pip3.6 install --no-cache-dir -r requirements_mysql.txt\n#  Run pyup.io's python package vulnerability check.\nRUN safety check\n#  Copy in the vendor resources and fetch them.\nCOPY fetch-vendor-resources.sh ./\nRUN ./fetch-vendor-resources.sh\n#  Copy in remaining source code. (We put this last because these\n#  change most frequently, so there is less to rebuild if we put\n#  infrequently changed steps above.)\n#\n#  NOTE: Do *not* include the \"local\" directory in this step, since\n#  that often has local development files. But *do* include fixtures\n#  so that tests can be run.\nCOPY VERSION ./VERSION\nCOPY discussion ./discussion\nCOPY guidedmodules ./guidedmodules\nCOPY modules ./modules\nCOPY siteapp ./siteapp\nCOPY templates ./templates\nCOPY fixtures ./fixtures\nCOPY testmocking ./testmocking\nCOPY manage.py .\n#  Flatten static files. Create a local/environment.json file that\n#  has the static directory set and only setting necessary for collectstatic\n#  to work. It matches what's set in dockerfile_exec.sh.\nRUN mkdir -p local \\\n && echo '{ \"static\": \"static_root\", \"debug\": false, \"host\": \"_\", \"https\": false }' > local/environment.json\nRUN python3.6 manage.py collectstatic --noinput\n#  Configure supervisord.\n#  a) Wipe out /var/{run,log} because when these directories are mounted with\n#     tmpfs they will be empty, so start them empty so the two setups match.\n#  b) Make /var/{run,log} world-writable because when we start the container with\n#     the non-root user it will need permission to write there.\n#  c) Move the supervisor log from /var/log/supervisor and the child process logs\n#     from /tmp to /var/log to make them all easily accessible if /var/log is mounted\n#     to a volume, and similarly the run socket from /var/run/supervisor.\n#     Otherwise we have to mess with file permissions so the inner directories are\n#     writable, and I couldn't get that to work. Even if the directories had chmod 777\n#     the non-root user could not create files inside them.\nRUN rm -rf /run/* /var/log/*\nRUN chmod a+rwx /run /var/log\nRUN sed -i \"s:/var/run/supervisor/:/var/run/:\" /etc/supervisord.conf\nRUN sed -i \"s:/var/log/supervisor/:/var/log/:\" /etc/supervisord.conf\nRUN sed -i \"s:^;childlogdir=/tmp:childlogdir=/var/log:\" /etc/supervisord.conf\nCOPY deployment/docker/supervisord.ini /etc/supervisord.d/application.ini\n#  Add container startup and management scripts.\nCOPY deployment/docker/dockerfile_exec.sh .\nCOPY deployment/docker/first_run.sh /usr/local/bin/first_run\nCOPY deployment/docker/uwsgi_stats.sh /usr/local/bin/uwsgi_stats\nCOPY deployment/docker/tail_logs.sh /usr/local/bin/tail_logs\n#  This directory must be present for the AppSource created by our\n#  first_run script. The directory only has something in it if\n#  the container is launched with --mount.\nRUN mkdir -p /mnt/apps\n#  Create a non-root user and group for the application to run as to guard against\n#  run-time modification of the system and application.\nRUN groupadd application \\\n && useradd -g application -d /home/application -s /sbin/nologin -c \"application process\" application \\\n && chown -R application:application /home/application\nRUN echo -n \"the non-root user is: \" \\\n && grep ^application /etc/passwd\n#  Give the non-root user access to scratch space.\nRUN mkdir -p local\nRUN chown -R application:application local\n#  Move the environment.json to /tmp because in some environments the main\n#  filesystem is read-only and we won't be able to update local/environment.json\n#  once the container starts. In those cases, /tmp must be a tmpfs. We use\n#  /tmp for other purposes at run-time as well. Although we don't need a\n#  working environment.json file for the remainder of this Dockerfile, downstream\n#  packagers using 'FROM govready/govready-q' might want to run additional\n#  management commands, so we'll keep it working.\nRUN cp local/environment.json /tmp\nRUN chown -R application:application /tmp/environment.json\nRUN ln -sf /tmp/environment.json local/environment.json\n#  Run the container's process zero as this user.\nUSER application\n#  Test.\nRUN python3.6 manage.py check\n#  Set the startup script.\nCMD [\"bash\", \"dockerfile_exec.sh\"]\n","injectedSmells":[],"originalDockerfileHash":"d7aed6fdeab990fa75dc67fc848be507","successfullyInjectedSmells":[],"originalDockerfileUglified":"#   Build on Docker's official CentOS 7 image.\nFROM centos:7\n#   Expose the port that `manage.py runserver` uses by default.\nEXPOSE 8000/tcp\n#   Put the Python source code here.\nWORKDIR /usr/src/app\n#   Set up the locale. Lots of things depend on this.\nENV LANG=\"en_US.UTF-8\"\nENV LC_ALL=\"en_US.UTF-8\"\nENV LANGUAGE=\"en_US:en\"\n#   Install required system packages.\n#   git2u: git 2 or later is required for our use of GIT_SSH_COMMAND in AppSourceConnection\n#   jq: we use it to assemble the local/environment.json file\nRUN yum -y install https://centos7.iuscommunity.org/ius-release.rpm \\\n && yum -y update \\\n && yum -y install python36u python36u-devel.x86_64 python36u-pip gcc-c++.x86_64 unzip git2u jq nmap-ncat graphviz pandoc xorg-x11-server-Xvfb wkhtmltopdf supervisor mysql-devel \\\n && yum clean all \\\n && rm -rf /var/cache/yum\n#   Copy in the Python module requirements and install them.\n#   Manually install database drivers which aren't in our requirements\n#   file because they're not commonly used in development.\nCOPY requirements.txt ./\nCOPY requirements_mysql.txt ./\nRUN pip3.6 install --no-cache-dir -r requirements.txt\nRUN pip3.6 install --no-cache-dir -r requirements_mysql.txt\n#   Run pyup.io's python package vulnerability check.\nRUN safety check\n#   Copy in the vendor resources and fetch them.\nCOPY fetch-vendor-resources.sh ./\nRUN ./fetch-vendor-resources.sh\n#   Copy in remaining source code. (We put this last because these\n#   change most frequently, so there is less to rebuild if we put\n#   infrequently changed steps above.)\n#\n#   NOTE: Do *not* include the \"local\" directory in this step, since\n#   that often has local development files. But *do* include fixtures\n#   so that tests can be run.\nCOPY VERSION ./VERSION\nCOPY discussion ./discussion\nCOPY guidedmodules ./guidedmodules\nCOPY modules ./modules\nCOPY siteapp ./siteapp\nCOPY templates ./templates\nCOPY fixtures ./fixtures\nCOPY testmocking ./testmocking\nCOPY manage.py .\n#   Flatten static files. Create a local/environment.json file that\n#   has the static directory set and only setting necessary for collectstatic\n#   to work. It matches what's set in dockerfile_exec.sh.\nRUN mkdir -p local \\\n && echo '{ \"static\": \"static_root\", \"debug\": false, \"host\": \"_\", \"https\": false }' > local/environment.json\nRUN python3.6 manage.py collectstatic --noinput\n#   Configure supervisord.\n#   a) Wipe out /var/{run,log} because when these directories are mounted with\n#      tmpfs they will be empty, so start them empty so the two setups match.\n#   b) Make /var/{run,log} world-writable because when we start the container with\n#      the non-root user it will need permission to write there.\n#   c) Move the supervisor log from /var/log/supervisor and the child process logs\n#      from /tmp to /var/log to make them all easily accessible if /var/log is mounted\n#      to a volume, and similarly the run socket from /var/run/supervisor.\n#      Otherwise we have to mess with file permissions so the inner directories are\n#      writable, and I couldn't get that to work. Even if the directories had chmod 777\n#      the non-root user could not create files inside them.\nRUN rm -rf /run/* /var/log/*\nRUN chmod a+rwx /run /var/log\nRUN sed -i \"s:/var/run/supervisor/:/var/run/:\" /etc/supervisord.conf\nRUN sed -i \"s:/var/log/supervisor/:/var/log/:\" /etc/supervisord.conf\nRUN sed -i \"s:^;childlogdir=/tmp:childlogdir=/var/log:\" /etc/supervisord.conf\nCOPY deployment/docker/supervisord.ini /etc/supervisord.d/application.ini\n#   Add container startup and management scripts.\nCOPY deployment/docker/dockerfile_exec.sh .\nCOPY deployment/docker/first_run.sh /usr/local/bin/first_run\nCOPY deployment/docker/uwsgi_stats.sh /usr/local/bin/uwsgi_stats\nCOPY deployment/docker/tail_logs.sh /usr/local/bin/tail_logs\n#   This directory must be present for the AppSource created by our\n#   first_run script. The directory only has something in it if\n#   the container is launched with --mount.\nRUN mkdir -p /mnt/apps\n#   Create a non-root user and group for the application to run as to guard against\n#   run-time modification of the system and application.\nRUN groupadd application \\\n && useradd -g application -d /home/application -s /sbin/nologin -c \"application process\" application \\\n && chown -R application:application /home/application\nRUN echo -n \"the non-root user is: \" \\\n && grep ^application /etc/passwd\n#   Give the non-root user access to scratch space.\nRUN mkdir -p local\nRUN chown -R application:application local\n#   Move the environment.json to /tmp because in some environments the main\n#   filesystem is read-only and we won't be able to update local/environment.json\n#   once the container starts. In those cases, /tmp must be a tmpfs. We use\n#   /tmp for other purposes at run-time as well. Although we don't need a\n#   working environment.json file for the remainder of this Dockerfile, downstream\n#   packagers using 'FROM govready/govready-q' might want to run additional\n#   management commands, so we'll keep it working.\nRUN cp local/environment.json /tmp\nRUN chown -R application:application /tmp/environment.json\nRUN ln -sf /tmp/environment.json local/environment.json\n#   Run the container's process zero as this user.\nUSER application\n#   Test.\nRUN python3.6 manage.py check\n#   Set the startup script.\nCMD [\"bash\", \"dockerfile_exec.sh\"]\n","originalDockerfileUglifiedHash":"3d5f39c882c2fba03070024f4bdc5f31","fileName":"/ICSME-replicationpackage/dataset/smelly_dockerfiles_bianncle/486549a2ee6603f1b31e8a5c21b0e9319cf2881d.dockerfile"}