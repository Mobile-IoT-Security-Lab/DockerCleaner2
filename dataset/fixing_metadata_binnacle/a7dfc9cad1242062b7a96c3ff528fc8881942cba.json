{"seed":3092666953,"processedDockerfileHash":"256ca8623171b881f803ad281b3438a3","fixedSmells":["use-no-install-recommends","do-not-use-apt-get-update-alone","pin-package-manager-versions-apt-get","pin-package-manager-versions-pip","pin-package-manager-versions-npm","pin-package-manager-versions-gem","pin-package-manager-versions-apk","use-copy-instead-of-add","use-wget-instead-of-add","do-not-have-secrets","have-a-healthcheck","have-a-user"],"successfullyFixedSmells":["have-a-healthcheck","have-a-user"],"processedDockerfile":"#  ######################################################################################\n#\n#   Dockerfile to start a GATB-Core compiling machine using these dependencies:\n#\n#       -->  clang 3.6 \n#       -->  CMake 3.1.3\n#\n#     See below to change these values.\n#\n#  --------------------------------------------------------------------------------------\n#\n#   Use:\n#\n#   ### To build the container, use: \n#    \n#       docker build -f Dockerfile.clang -t gatb_core_machine_clang .\n#\n#   ### To run the container.\n#\n#     Running the container means that you want to compile GATB-Core. For that \n#     purpose, docker run expects some information, as illustrated in this\n#     command:\n#   \n#     docker run \\\n#       -i -t \\\n#       -e \"GIT_BRANCH=master\"                             <-- branch to build\n#       -v /path/to/gatb-core-source:/tmp/gatb-core-code \\ <-- source code\n#       -v /path/to/gatb-core-build:/tmp/gatb-core-build \\ <-- compiled code\n#       gatb_core_machine_clang \\                          <-- container to start\n#       gatb-compile.sh                                    <-- script to run\n#\n#     First of all, we have retain that the code is not compiled within the\n#     container. Instead we use two external volumes bound to the container using\n#     two docker run \"-v\" arguments. These two volumes simply target:\n#\n#        1. a directory containing the GATB-Core source code, i.e. a \"git clone\" of\n#           GATB-Core repository;\n#        2. a directory containing the compiled code.\n#\n#     Using such a design, you can work with an existing clone of GATB-Core \n#     repository and you can easily access the compiled code.\n#\n#     GATB-Core source code directory (hereafter denoted as \"gatb-core-source\") must\n#     exist on the host system, but it can be empty. In such a case, the container\n#     will do the git clone. Thus, gatb-core-source is passed to docker run as \n#     follows:\n#\n#        -v /full/path/to/your/gatb-core-source:/tmp/gatb-core-code\n#\n#        (do not modify \"/tmp/gatb-core-code\": this is the mount path within the \n#         container)\n#\n#     GATB-Core compiled code directory (hereafter denoted as \"gatb-core-build\")\n#     must also exist on the host system. In all case, the container will erase its\n#     content before running the code compiling procedure.  Thus, gatb-core-build \n#     is passed to docker run as follows:\n#\n#        -v /full/path/to/your/gatb-core-build:/tmp/gatb-core-build\n#\n#        (do not modify \"/tmp/gatb-core-build\": this is the mount path within the \n#         container)\n#\n#     Finally, the docker run also accepts an optional environment variable: the \n#     GATB-Core branch to compile. Simply pass that information using the \"-e\"\n#     argument of docker run as follows:\n#\n#        -e \"GIT_BRANCH=master\"\n#\n#        replace \"master\" by an appropriate value, i.e. a git branch or tag.\n#\n#     If \"-e\" is not provided to docker run, then the master branch of GATB-Core \n#     is compiled.\n#\n#     All in all, the GATB-Core compiler machine can be started as follows:\n#\n#     docker run --name gatb_core_machine_clang \\\n#                -i -t \\                       <-- remove if running from Jenkins/slave\n#                                                  (TTY not allowed)\n#                -e \"GIT_BRANCH=master\"\n#                -v /path/to/gatb-core-source:/tmp/gatb-core-code \\\n#                -v /path/to/gatb-core-build:/tmp/gatb-core-build \\\n#                gatb_core_machine_clang \\\n#                gatb-compile.sh\n#\n#     Sample command from the real life: docker run --name gatb_core_machine_clang -i -t -e \"GIT_BRANCH=master\" -v /Users/pdurand/tmp/gatb-core/docker:/tmp/gatb-core-code -v /Users/pdurand/tmp/gatb-core/docker:/tmp/gatb-core-build gatb_core_machine_clang gatb-compile.sh\n#\n#   ### Test compile code.\n#\n#     In the above docker run command, you can replace \n#\n#       gatb-compile.sh \n#\n#     by \n#\n#       gatb-test.sh \n#\n#     to run unit tests of the freshly compiled GATB-Core library.\n#                              \n#   ### Additional notes\n#   \n#     Root access inside the container:\n#\n#       - if running: docker exec -it gatb_core_machine_clang bash\n#\n#       - if not yet running: docker run --rm -i -t gatb_core_machine_clang bash\n#\n#  ######################################################################################\n#   ###\n#       Base commands\n#\n#       We use a Debian 8 (Jessie) Linux\n#\nFROM debian:jessie\n#   who to blame?\nMAINTAINER Patrick Durand patrick.durand@inria.fr\n#   ###\n#      Configuring gcc and cmake release\n#\nENV CLANG_VERSION=\"3.6\" \\\n    CMAKE_SERIES=\"3.1\" \\\n    CMAKE_VERSION=\"3.1.3\"\n#   ###\n#       Package installation and configuration\n#\n#       install latest packages of the base system\n#       as well as packages required to compile GATB-Core\n#       Note: 'software-properties-commo'n contains 'add-apt-repository' tool.\n#             It is required to to install clang/llvm.\n#\nRUN apt-get update \\\n && apt-get -y dist-upgrade \\\n && apt-get install --no-install-recommends software-properties-common vim git wget make zlib1g-dev libcppunit-dev -y \\\n && apt-get clean \\\n && git config --global http.sslVerify false\n#   ###\n#       Compiler installation\n#\n#       We need a clang/llvm compiler in an appropriate release.\n#       Reference: http://apt.llvm.org/\n#\nRUN add-apt-repository \"deb http://apt.llvm.org/jessie/ llvm-toolchain-jessie-${CLANG_VERSION} main\" \\\n && wget -O - http://apt.llvm.org/llvm-snapshot.gpg.key | apt-key add - \\\n && apt-get update \\\n && apt-get install --no-install-recommends clang-${CLANG_VERSION} lldb-${CLANG_VERSION} -y \\\n && apt-get clean\n#   ###\n#       CMAKE installation\n#\n#       we need cmake in aparticular release; we do not use: apt-get \n#       install cmake since we have to control which version we use.\n#       Cmake install procedure: https://cmake.org/install/\n#\nENV CC=\"/usr/bin/clang-${CLANG_VERSION}\" \\\n    CXX=\"/usr/bin/clang++-${CLANG_VERSION}\"\nRUN cd /opt \\\n && export CMAKE_URL=\"http://cmake.org/files/v${CMAKE_SERIES}/cmake-${CMAKE_VERSION}.tar.gz\" \\\n && wget --no-check-certificate ${CMAKE_URL} -O - | tar xzf - \\\n && cd cmake-${CMAKE_VERSION} \\\n && ./bootstrap \\\n && make \\\n && make install \\\n && cd /opt \\\n && rm -rf cmake-${CMAKE_VERSION}\n#   ###\n#       GATB-Core management scripts\n#\nCOPY *.sh /usr/local/bin/\nRUN groupadd --system docker-user ; useradd --system --gid docker-user docker-user\nUSER docker-user\n# Please add your HEALTHCHECK here!!!\n","originalDockerfile":"# ######################################################################################\n#\n#  Dockerfile to start a GATB-Core compiling machine using these dependencies:\n#\n#      -->  clang 3.6 \n#      -->  CMake 3.1.3\n#\n#    See below to change these values.\n#\n# --------------------------------------------------------------------------------------\n#\n#  Use:\n#\n#  ### To build the container, use: \n#   \n#      docker build -f Dockerfile.clang -t gatb_core_machine_clang .\n#\n#  ### To run the container.\n#\n#    Running the container means that you want to compile GATB-Core. For that \n#    purpose, docker run expects some information, as illustrated in this\n#    command:\n#  \n#    docker run \\\n#      -i -t \\\n#      -e \"GIT_BRANCH=master\"                             <-- branch to build\n#      -v /path/to/gatb-core-source:/tmp/gatb-core-code \\ <-- source code\n#      -v /path/to/gatb-core-build:/tmp/gatb-core-build \\ <-- compiled code\n#      gatb_core_machine_clang \\                          <-- container to start\n#      gatb-compile.sh                                    <-- script to run\n#\n#    First of all, we have retain that the code is not compiled within the\n#    container. Instead we use two external volumes bound to the container using\n#    two docker run \"-v\" arguments. These two volumes simply target:\n#\n#       1. a directory containing the GATB-Core source code, i.e. a \"git clone\" of\n#          GATB-Core repository;\n#       2. a directory containing the compiled code.\n#\n#    Using such a design, you can work with an existing clone of GATB-Core \n#    repository and you can easily access the compiled code.\n#\n#    GATB-Core source code directory (hereafter denoted as \"gatb-core-source\") must\n#    exist on the host system, but it can be empty. In such a case, the container\n#    will do the git clone. Thus, gatb-core-source is passed to docker run as \n#    follows:\n#\n#       -v /full/path/to/your/gatb-core-source:/tmp/gatb-core-code\n#\n#       (do not modify \"/tmp/gatb-core-code\": this is the mount path within the \n#        container)\n#\n#    GATB-Core compiled code directory (hereafter denoted as \"gatb-core-build\")\n#    must also exist on the host system. In all case, the container will erase its\n#    content before running the code compiling procedure.  Thus, gatb-core-build \n#    is passed to docker run as follows:\n#\n#       -v /full/path/to/your/gatb-core-build:/tmp/gatb-core-build\n#\n#       (do not modify \"/tmp/gatb-core-build\": this is the mount path within the \n#        container)\n#\n#    Finally, the docker run also accepts an optional environment variable: the \n#    GATB-Core branch to compile. Simply pass that information using the \"-e\"\n#    argument of docker run as follows:\n#\n#       -e \"GIT_BRANCH=master\"\n#\n#       replace \"master\" by an appropriate value, i.e. a git branch or tag.\n#\n#    If \"-e\" is not provided to docker run, then the master branch of GATB-Core \n#    is compiled.\n#\n#    All in all, the GATB-Core compiler machine can be started as follows:\n#\n#    docker run --name gatb_core_machine_clang \\\n#               -i -t \\                       <-- remove if running from Jenkins/slave\n#                                                 (TTY not allowed)\n#               -e \"GIT_BRANCH=master\"\n#               -v /path/to/gatb-core-source:/tmp/gatb-core-code \\\n#               -v /path/to/gatb-core-build:/tmp/gatb-core-build \\\n#               gatb_core_machine_clang \\\n#               gatb-compile.sh\n#\n#    Sample command from the real life: docker run --name gatb_core_machine_clang -i -t -e \"GIT_BRANCH=master\" -v /Users/pdurand/tmp/gatb-core/docker:/tmp/gatb-core-code -v /Users/pdurand/tmp/gatb-core/docker:/tmp/gatb-core-build gatb_core_machine_clang gatb-compile.sh\n#\n#  ### Test compile code.\n#\n#    In the above docker run command, you can replace \n#\n#      gatb-compile.sh \n#\n#    by \n#\n#      gatb-test.sh \n#\n#    to run unit tests of the freshly compiled GATB-Core library.\n#                             \n#  ### Additional notes\n#  \n#    Root access inside the container:\n#\n#      - if running: docker exec -it gatb_core_machine_clang bash\n#\n#      - if not yet running: docker run --rm -i -t gatb_core_machine_clang bash\n#\n# ######################################################################################\n#  ###\n#      Base commands\n#\n#      We use a Debian 8 (Jessie) Linux\n#\nFROM debian:jessie\n#  who to blame?\nMAINTAINER Patrick Durand patrick.durand@inria.fr\n#  ###\n#     Configuring gcc and cmake release\n#\nENV CLANG_VERSION=\"3.6\" \\\n    CMAKE_SERIES=\"3.1\" \\\n    CMAKE_VERSION=\"3.1.3\"\n#  ###\n#      Package installation and configuration\n#\n#      install latest packages of the base system\n#      as well as packages required to compile GATB-Core\n#      Note: 'software-properties-commo'n contains 'add-apt-repository' tool.\n#            It is required to to install clang/llvm.\n#\nRUN apt-get update \\\n && apt-get -y dist-upgrade \\\n && apt-get install --no-install-recommends software-properties-common vim git wget make zlib1g-dev libcppunit-dev -y \\\n && apt-get clean \\\n && git config --global http.sslVerify false\n#  ###\n#      Compiler installation\n#\n#      We need a clang/llvm compiler in an appropriate release.\n#      Reference: http://apt.llvm.org/\n#\nRUN add-apt-repository \"deb http://apt.llvm.org/jessie/ llvm-toolchain-jessie-${CLANG_VERSION} main\" \\\n && wget -O - http://apt.llvm.org/llvm-snapshot.gpg.key | apt-key add - \\\n && apt-get update \\\n && apt-get install --no-install-recommends clang-${CLANG_VERSION} lldb-${CLANG_VERSION} -y \\\n && apt-get clean\n#  ###\n#      CMAKE installation\n#\n#      we need cmake in aparticular release; we do not use: apt-get \n#      install cmake since we have to control which version we use.\n#      Cmake install procedure: https://cmake.org/install/\n#\nENV CC=\"/usr/bin/clang-${CLANG_VERSION}\" \\\n    CXX=\"/usr/bin/clang++-${CLANG_VERSION}\"\nRUN cd /opt \\\n && export CMAKE_URL=\"http://cmake.org/files/v${CMAKE_SERIES}/cmake-${CMAKE_VERSION}.tar.gz\" \\\n && wget --no-check-certificate ${CMAKE_URL} -O - | tar xzf - \\\n && cd cmake-${CMAKE_VERSION} \\\n && ./bootstrap \\\n && make \\\n && make install \\\n && cd /opt \\\n && rm -rf cmake-${CMAKE_VERSION}\n#  ###\n#      GATB-Core management scripts\n#\nCOPY *.sh /usr/local/bin/\n","injectedSmells":[],"originalDockerfileHash":"c7e190cae5957ac9baf1af5ab8565a49","successfullyInjectedSmells":[],"originalDockerfileUglified":"#  ######################################################################################\n#\n#   Dockerfile to start a GATB-Core compiling machine using these dependencies:\n#\n#       -->  clang 3.6 \n#       -->  CMake 3.1.3\n#\n#     See below to change these values.\n#\n#  --------------------------------------------------------------------------------------\n#\n#   Use:\n#\n#   ### To build the container, use: \n#    \n#       docker build -f Dockerfile.clang -t gatb_core_machine_clang .\n#\n#   ### To run the container.\n#\n#     Running the container means that you want to compile GATB-Core. For that \n#     purpose, docker run expects some information, as illustrated in this\n#     command:\n#   \n#     docker run \\\n#       -i -t \\\n#       -e \"GIT_BRANCH=master\"                             <-- branch to build\n#       -v /path/to/gatb-core-source:/tmp/gatb-core-code \\ <-- source code\n#       -v /path/to/gatb-core-build:/tmp/gatb-core-build \\ <-- compiled code\n#       gatb_core_machine_clang \\                          <-- container to start\n#       gatb-compile.sh                                    <-- script to run\n#\n#     First of all, we have retain that the code is not compiled within the\n#     container. Instead we use two external volumes bound to the container using\n#     two docker run \"-v\" arguments. These two volumes simply target:\n#\n#        1. a directory containing the GATB-Core source code, i.e. a \"git clone\" of\n#           GATB-Core repository;\n#        2. a directory containing the compiled code.\n#\n#     Using such a design, you can work with an existing clone of GATB-Core \n#     repository and you can easily access the compiled code.\n#\n#     GATB-Core source code directory (hereafter denoted as \"gatb-core-source\") must\n#     exist on the host system, but it can be empty. In such a case, the container\n#     will do the git clone. Thus, gatb-core-source is passed to docker run as \n#     follows:\n#\n#        -v /full/path/to/your/gatb-core-source:/tmp/gatb-core-code\n#\n#        (do not modify \"/tmp/gatb-core-code\": this is the mount path within the \n#         container)\n#\n#     GATB-Core compiled code directory (hereafter denoted as \"gatb-core-build\")\n#     must also exist on the host system. In all case, the container will erase its\n#     content before running the code compiling procedure.  Thus, gatb-core-build \n#     is passed to docker run as follows:\n#\n#        -v /full/path/to/your/gatb-core-build:/tmp/gatb-core-build\n#\n#        (do not modify \"/tmp/gatb-core-build\": this is the mount path within the \n#         container)\n#\n#     Finally, the docker run also accepts an optional environment variable: the \n#     GATB-Core branch to compile. Simply pass that information using the \"-e\"\n#     argument of docker run as follows:\n#\n#        -e \"GIT_BRANCH=master\"\n#\n#        replace \"master\" by an appropriate value, i.e. a git branch or tag.\n#\n#     If \"-e\" is not provided to docker run, then the master branch of GATB-Core \n#     is compiled.\n#\n#     All in all, the GATB-Core compiler machine can be started as follows:\n#\n#     docker run --name gatb_core_machine_clang \\\n#                -i -t \\                       <-- remove if running from Jenkins/slave\n#                                                  (TTY not allowed)\n#                -e \"GIT_BRANCH=master\"\n#                -v /path/to/gatb-core-source:/tmp/gatb-core-code \\\n#                -v /path/to/gatb-core-build:/tmp/gatb-core-build \\\n#                gatb_core_machine_clang \\\n#                gatb-compile.sh\n#\n#     Sample command from the real life: docker run --name gatb_core_machine_clang -i -t -e \"GIT_BRANCH=master\" -v /Users/pdurand/tmp/gatb-core/docker:/tmp/gatb-core-code -v /Users/pdurand/tmp/gatb-core/docker:/tmp/gatb-core-build gatb_core_machine_clang gatb-compile.sh\n#\n#   ### Test compile code.\n#\n#     In the above docker run command, you can replace \n#\n#       gatb-compile.sh \n#\n#     by \n#\n#       gatb-test.sh \n#\n#     to run unit tests of the freshly compiled GATB-Core library.\n#                              \n#   ### Additional notes\n#   \n#     Root access inside the container:\n#\n#       - if running: docker exec -it gatb_core_machine_clang bash\n#\n#       - if not yet running: docker run --rm -i -t gatb_core_machine_clang bash\n#\n#  ######################################################################################\n#   ###\n#       Base commands\n#\n#       We use a Debian 8 (Jessie) Linux\n#\nFROM debian:jessie\n#   who to blame?\nMAINTAINER Patrick Durand patrick.durand@inria.fr\n#   ###\n#      Configuring gcc and cmake release\n#\nENV CLANG_VERSION=\"3.6\" \\\n    CMAKE_SERIES=\"3.1\" \\\n    CMAKE_VERSION=\"3.1.3\"\n#   ###\n#       Package installation and configuration\n#\n#       install latest packages of the base system\n#       as well as packages required to compile GATB-Core\n#       Note: 'software-properties-commo'n contains 'add-apt-repository' tool.\n#             It is required to to install clang/llvm.\n#\nRUN apt-get update \\\n && apt-get -y dist-upgrade \\\n && apt-get install --no-install-recommends software-properties-common vim git wget make zlib1g-dev libcppunit-dev -y \\\n && apt-get clean \\\n && git config --global http.sslVerify false\n#   ###\n#       Compiler installation\n#\n#       We need a clang/llvm compiler in an appropriate release.\n#       Reference: http://apt.llvm.org/\n#\nRUN add-apt-repository \"deb http://apt.llvm.org/jessie/ llvm-toolchain-jessie-${CLANG_VERSION} main\" \\\n && wget -O - http://apt.llvm.org/llvm-snapshot.gpg.key | apt-key add - \\\n && apt-get update \\\n && apt-get install --no-install-recommends clang-${CLANG_VERSION} lldb-${CLANG_VERSION} -y \\\n && apt-get clean\n#   ###\n#       CMAKE installation\n#\n#       we need cmake in aparticular release; we do not use: apt-get \n#       install cmake since we have to control which version we use.\n#       Cmake install procedure: https://cmake.org/install/\n#\nENV CC=\"/usr/bin/clang-${CLANG_VERSION}\" \\\n    CXX=\"/usr/bin/clang++-${CLANG_VERSION}\"\nRUN cd /opt \\\n && export CMAKE_URL=\"http://cmake.org/files/v${CMAKE_SERIES}/cmake-${CMAKE_VERSION}.tar.gz\" \\\n && wget --no-check-certificate ${CMAKE_URL} -O - | tar xzf - \\\n && cd cmake-${CMAKE_VERSION} \\\n && ./bootstrap \\\n && make \\\n && make install \\\n && cd /opt \\\n && rm -rf cmake-${CMAKE_VERSION}\n#   ###\n#       GATB-Core management scripts\n#\nCOPY *.sh /usr/local/bin/\n","originalDockerfileUglifiedHash":"8cb469b1d5d9d251134ff1c1a7ca0897","fileName":"/ICSME-replicationpackage/dataset/smelly_dockerfiles_bianncle/a7dfc9cad1242062b7a96c3ff528fc8881942cba.dockerfile"}