{"seed":920297831,"processedDockerfileHash":"fa7c24818b7a0cf98fc9b32cf106b70b","fixedSmells":["use-no-install-recommends","do-not-use-apt-get-update-alone","pin-package-manager-versions-apt-get","pin-package-manager-versions-pip","pin-package-manager-versions-npm","pin-package-manager-versions-gem","pin-package-manager-versions-apk","use-copy-instead-of-add","use-wget-instead-of-add","do-not-have-secrets","have-a-healthcheck","have-a-user"],"successfullyFixedSmells":["pin-package-manager-versions-apk","have-a-healthcheck","have-a-user"],"processedDockerfile":"#   Copyright 2017 Google LLC\n#\n#   Licensed under the Apache License, Version 2.0 (the \"License\");\n#   you may not use this file except in compliance with the License.\n#   You may obtain a copy of the License at\n#\n#       http://www.apache.org/licenses/LICENSE-2.0\n#\n#   Unless required by applicable law or agreed to in writing, software\n#   distributed under the License is distributed on an \"AS IS\" BASIS,\n#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#   See the License for the specific language governing permissions and\n#   limitations under the License.\n#   This is a sample Dockerfile for packaging an Elixir Phoenix application\n#   as a Docker image. It builds a Distillery release and installs it on\n#   Alpine Linux. The final image launches the application on port 8080. It\n#   requires the project ID to be passed in the project_id build arg.\n#\n#   This Dockerfile includes two stages and requires Docker 17.05 or later.\n#\n#   To adapt this Dockerfile to your app, you may need to customize the app_name\n#   and phoenix_subdir build arguments, as outlined below.\n#  ###############################################################################\n#   BUILD STAGE\n#\n#   Builds the app, does a Brunch build to build the assets, and creates a\n#   release. This stage uses the official Alpine Linux - Elixir base image, and\n#   installs a few additional build tools such as Node.js.\nFROM elixir:alpine\n#  #############################################################################\n#  # Build arguments. Modify these to adapt this Dockerfile to your app.      ##\n#  # Alternatively, you may specify --build-arg when running `docker build`.  ##\n#  # The name of your Phoenix application.                                    ##\nARG app_name=hello\n#  # The subdirectory of the Phoenix application within the toplevel project. ##\n#  # If your project is an umbrella project, this should be the relative path ##\n#  # to the Phoenix application, e.g. \"apps/hello_web\". If this is a simple   ##\n#  # project, this should be \".\"                                              ##\nARG phoenix_subdir=.\n#  # End build arguments.                                                     ##\n#  #############################################################################\n#   Set up build environment.\nENV MIX_ENV=\"prod\" \\\n    REPLACE_OS_VARS=\"true\" \\\n    TERM=\"xterm\"\n#   Set the build directory.\nWORKDIR /opt/app\n#   Install build tools needed in addition to Elixir:\n#   NodeJS is used for Webpack builds of Phoenix assets.\n#   Hex and Rebar are needed to get and build dependencies.\nRUN apk update \\\n && apk add nodejs=18.14.2-r0 nodejs-npm --no-cache --update \\\n && mix local.rebar --force \\\n && mix local.hex --force\n#   Copy the application files into /opt/app.\nCOPY . .\n#   Build the application.\nRUN mix do deps.get, deps.compile, compile\n#   Build assets by running a Webpack build and Phoenix digest.\n#   If you are using a different mechanism for asset builds, you may need to\n#   alter these commands.\nRUN cd ${phoenix_subdir}/assets \\\n && npm install \\\n && ./node_modules/webpack/bin/webpack.js --mode production \\\n && cd .. \\\n && mix phx.digest\n#   Create the release, and move the artifacts to well-known paths so the\n#   runtime image doesn't need to know the app name. Specifically, the binary\n#   is renamed to \"start_server\", and the entire release is moved into\n#   /opt/release.\nRUN mix release --env=prod --verbose \\\n && mv _build/prod/rel/${app_name} /opt/release \\\n && mv /opt/release/bin/${app_name} /opt/release/bin/start_server\n#  ###############################################################################\n#   RUNTIME STAGE\n#\n#   Creates the actual runtime image. This is based on a the Alpine Linux base\n#   image, with only the minimum dependencies for running ERTS and the Cloud SQL\n#   Proxy.\nFROM alpine:latest\n#   The Google Cloud project ID must be provided via a --build-arg.\nARG project_id\nENV GCLOUD_PROJECT_ID=\"${project_id}\"\n#   Install dependencies. Bash and OpenSSL are required for ERTS. Also install\n#   certificates needed to communicate with Google Cloud APIs over HTTPS.\nRUN apk update \\\n && apk add bash=5.2.15-r0 ca-certificates=20220614-r4 openssl-dev=3.0.8-r3 --no-cache --update\n#   Install the Cloud SQL Proxy in /usr/local/bin/. Also create the directory\n#   /tmp/cloudsql where SQL connection sockets will be kept.\nRUN mkdir -p /usr/local/bin \\\n && wget https://dl.google.com/cloudsql/cloud_sql_proxy.linux.amd64 -O /usr/local/bin/cloud_sql_proxy \\\n && chmod +x /usr/local/bin/cloud_sql_proxy \\\n && mkdir -p /tmp/cloudsql\n#   This is the runtime environment for a Phoenix app.\n#   It listens on port 8080, and runs in the prod environment.\nENV PORT=\"8080\" \\\n    MIX_ENV=\"prod\" \\\n    REPLACE_OS_VARS=\"true\"\nEXPOSE ${PORT}\n#   Set the install directory. The app will run from here.\nWORKDIR /opt/app\n#   Obtain the built application release from the build stage.\nCOPY --from=0 /opt/release .\n#   Start the server. This first starts the Cloud SQL Proxy in the background,\n#   then runs the release in the foreground. This will work for simple\n#   deployments, but a more robust deployment might run the Cloud SQL Proxy in a\n#   sidecar container.\nCMD (/usr/local/bin/cloud_sql_proxy -projects=${GCLOUD_PROJECT_ID} -dir=/tmp/cloudsql &) ; exec /opt/app/bin/start_server foreground\nRUN addgroup -S docker-user ; adduser -S -G docker-user docker-user\nUSER docker-user\n# Please add your HEALTHCHECK here!!!\n","originalDockerfile":"#  Copyright 2017 Google LLC\n#\n#  Licensed under the Apache License, Version 2.0 (the \"License\");\n#  you may not use this file except in compliance with the License.\n#  You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n#  Unless required by applicable law or agreed to in writing, software\n#  distributed under the License is distributed on an \"AS IS\" BASIS,\n#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#  See the License for the specific language governing permissions and\n#  limitations under the License.\n#  This is a sample Dockerfile for packaging an Elixir Phoenix application\n#  as a Docker image. It builds a Distillery release and installs it on\n#  Alpine Linux. The final image launches the application on port 8080. It\n#  requires the project ID to be passed in the project_id build arg.\n#\n#  This Dockerfile includes two stages and requires Docker 17.05 or later.\n#\n#  To adapt this Dockerfile to your app, you may need to customize the app_name\n#  and phoenix_subdir build arguments, as outlined below.\n# ###############################################################################\n#  BUILD STAGE\n#\n#  Builds the app, does a Brunch build to build the assets, and creates a\n#  release. This stage uses the official Alpine Linux - Elixir base image, and\n#  installs a few additional build tools such as Node.js.\nFROM elixir:alpine\n# #############################################################################\n# # Build arguments. Modify these to adapt this Dockerfile to your app.      ##\n# # Alternatively, you may specify --build-arg when running `docker build`.  ##\n# # The name of your Phoenix application.                                    ##\nARG app_name=hello\n# # The subdirectory of the Phoenix application within the toplevel project. ##\n# # If your project is an umbrella project, this should be the relative path ##\n# # to the Phoenix application, e.g. \"apps/hello_web\". If this is a simple   ##\n# # project, this should be \".\"                                              ##\nARG phoenix_subdir=.\n# # End build arguments.                                                     ##\n# #############################################################################\n#  Set up build environment.\nENV MIX_ENV=\"prod\" \\\n    REPLACE_OS_VARS=\"true\" \\\n    TERM=\"xterm\"\n#  Set the build directory.\nWORKDIR /opt/app\n#  Install build tools needed in addition to Elixir:\n#  NodeJS is used for Webpack builds of Phoenix assets.\n#  Hex and Rebar are needed to get and build dependencies.\nRUN apk update \\\n && apk --no-cache --update add nodejs nodejs-npm \\\n && mix local.rebar --force \\\n && mix local.hex --force\n#  Copy the application files into /opt/app.\nCOPY . .\n#  Build the application.\nRUN mix do deps.get, deps.compile, compile\n#  Build assets by running a Webpack build and Phoenix digest.\n#  If you are using a different mechanism for asset builds, you may need to\n#  alter these commands.\nRUN cd ${phoenix_subdir}/assets \\\n && npm install \\\n && ./node_modules/webpack/bin/webpack.js --mode production \\\n && cd .. \\\n && mix phx.digest\n#  Create the release, and move the artifacts to well-known paths so the\n#  runtime image doesn't need to know the app name. Specifically, the binary\n#  is renamed to \"start_server\", and the entire release is moved into\n#  /opt/release.\nRUN mix release --env=prod --verbose \\\n && mv _build/prod/rel/${app_name} /opt/release \\\n && mv /opt/release/bin/${app_name} /opt/release/bin/start_server\n# ###############################################################################\n#  RUNTIME STAGE\n#\n#  Creates the actual runtime image. This is based on a the Alpine Linux base\n#  image, with only the minimum dependencies for running ERTS and the Cloud SQL\n#  Proxy.\nFROM alpine:latest\n#  The Google Cloud project ID must be provided via a --build-arg.\nARG project_id\nENV GCLOUD_PROJECT_ID=\"${project_id}\"\n#  Install dependencies. Bash and OpenSSL are required for ERTS. Also install\n#  certificates needed to communicate with Google Cloud APIs over HTTPS.\nRUN apk update \\\n && apk --no-cache --update add bash ca-certificates openssl-dev\n#  Install the Cloud SQL Proxy in /usr/local/bin/. Also create the directory\n#  /tmp/cloudsql where SQL connection sockets will be kept.\nRUN mkdir -p /usr/local/bin \\\n && wget https://dl.google.com/cloudsql/cloud_sql_proxy.linux.amd64 -O /usr/local/bin/cloud_sql_proxy \\\n && chmod +x /usr/local/bin/cloud_sql_proxy \\\n && mkdir -p /tmp/cloudsql\n#  This is the runtime environment for a Phoenix app.\n#  It listens on port 8080, and runs in the prod environment.\nENV PORT=\"8080\" \\\n    MIX_ENV=\"prod\" \\\n    REPLACE_OS_VARS=\"true\"\nEXPOSE ${PORT}\n#  Set the install directory. The app will run from here.\nWORKDIR /opt/app\n#  Obtain the built application release from the build stage.\nCOPY --from=0 /opt/release .\n#  Start the server. This first starts the Cloud SQL Proxy in the background,\n#  then runs the release in the foreground. This will work for simple\n#  deployments, but a more robust deployment might run the Cloud SQL Proxy in a\n#  sidecar container.\nCMD (/usr/local/bin/cloud_sql_proxy -projects=${GCLOUD_PROJECT_ID} -dir=/tmp/cloudsql &) ; exec /opt/app/bin/start_server foreground\n","injectedSmells":[],"originalDockerfileHash":"8efb1571c94a47137a82902736daa167","successfullyInjectedSmells":[],"originalDockerfileUglified":"#   Copyright 2017 Google LLC\n#\n#   Licensed under the Apache License, Version 2.0 (the \"License\");\n#   you may not use this file except in compliance with the License.\n#   You may obtain a copy of the License at\n#\n#       http://www.apache.org/licenses/LICENSE-2.0\n#\n#   Unless required by applicable law or agreed to in writing, software\n#   distributed under the License is distributed on an \"AS IS\" BASIS,\n#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#   See the License for the specific language governing permissions and\n#   limitations under the License.\n#   This is a sample Dockerfile for packaging an Elixir Phoenix application\n#   as a Docker image. It builds a Distillery release and installs it on\n#   Alpine Linux. The final image launches the application on port 8080. It\n#   requires the project ID to be passed in the project_id build arg.\n#\n#   This Dockerfile includes two stages and requires Docker 17.05 or later.\n#\n#   To adapt this Dockerfile to your app, you may need to customize the app_name\n#   and phoenix_subdir build arguments, as outlined below.\n#  ###############################################################################\n#   BUILD STAGE\n#\n#   Builds the app, does a Brunch build to build the assets, and creates a\n#   release. This stage uses the official Alpine Linux - Elixir base image, and\n#   installs a few additional build tools such as Node.js.\nFROM elixir:alpine\n#  #############################################################################\n#  # Build arguments. Modify these to adapt this Dockerfile to your app.      ##\n#  # Alternatively, you may specify --build-arg when running `docker build`.  ##\n#  # The name of your Phoenix application.                                    ##\nARG app_name=hello\n#  # The subdirectory of the Phoenix application within the toplevel project. ##\n#  # If your project is an umbrella project, this should be the relative path ##\n#  # to the Phoenix application, e.g. \"apps/hello_web\". If this is a simple   ##\n#  # project, this should be \".\"                                              ##\nARG phoenix_subdir=.\n#  # End build arguments.                                                     ##\n#  #############################################################################\n#   Set up build environment.\nENV MIX_ENV=\"prod\" \\\n    REPLACE_OS_VARS=\"true\" \\\n    TERM=\"xterm\"\n#   Set the build directory.\nWORKDIR /opt/app\n#   Install build tools needed in addition to Elixir:\n#   NodeJS is used for Webpack builds of Phoenix assets.\n#   Hex and Rebar are needed to get and build dependencies.\nRUN apk update \\\n && apk --no-cache --update add nodejs nodejs-npm \\\n && mix local.rebar --force \\\n && mix local.hex --force\n#   Copy the application files into /opt/app.\nCOPY . .\n#   Build the application.\nRUN mix do deps.get, deps.compile, compile\n#   Build assets by running a Webpack build and Phoenix digest.\n#   If you are using a different mechanism for asset builds, you may need to\n#   alter these commands.\nRUN cd ${phoenix_subdir}/assets \\\n && npm install \\\n && ./node_modules/webpack/bin/webpack.js --mode production \\\n && cd .. \\\n && mix phx.digest\n#   Create the release, and move the artifacts to well-known paths so the\n#   runtime image doesn't need to know the app name. Specifically, the binary\n#   is renamed to \"start_server\", and the entire release is moved into\n#   /opt/release.\nRUN mix release --env=prod --verbose \\\n && mv _build/prod/rel/${app_name} /opt/release \\\n && mv /opt/release/bin/${app_name} /opt/release/bin/start_server\n#  ###############################################################################\n#   RUNTIME STAGE\n#\n#   Creates the actual runtime image. This is based on a the Alpine Linux base\n#   image, with only the minimum dependencies for running ERTS and the Cloud SQL\n#   Proxy.\nFROM alpine:latest\n#   The Google Cloud project ID must be provided via a --build-arg.\nARG project_id\nENV GCLOUD_PROJECT_ID=\"${project_id}\"\n#   Install dependencies. Bash and OpenSSL are required for ERTS. Also install\n#   certificates needed to communicate with Google Cloud APIs over HTTPS.\nRUN apk update \\\n && apk --no-cache --update add bash ca-certificates openssl-dev\n#   Install the Cloud SQL Proxy in /usr/local/bin/. Also create the directory\n#   /tmp/cloudsql where SQL connection sockets will be kept.\nRUN mkdir -p /usr/local/bin \\\n && wget https://dl.google.com/cloudsql/cloud_sql_proxy.linux.amd64 -O /usr/local/bin/cloud_sql_proxy \\\n && chmod +x /usr/local/bin/cloud_sql_proxy \\\n && mkdir -p /tmp/cloudsql\n#   This is the runtime environment for a Phoenix app.\n#   It listens on port 8080, and runs in the prod environment.\nENV PORT=\"8080\" \\\n    MIX_ENV=\"prod\" \\\n    REPLACE_OS_VARS=\"true\"\nEXPOSE ${PORT}\n#   Set the install directory. The app will run from here.\nWORKDIR /opt/app\n#   Obtain the built application release from the build stage.\nCOPY --from=0 /opt/release .\n#   Start the server. This first starts the Cloud SQL Proxy in the background,\n#   then runs the release in the foreground. This will work for simple\n#   deployments, but a more robust deployment might run the Cloud SQL Proxy in a\n#   sidecar container.\nCMD (/usr/local/bin/cloud_sql_proxy -projects=${GCLOUD_PROJECT_ID} -dir=/tmp/cloudsql &) ; exec /opt/app/bin/start_server foreground\n","originalDockerfileUglifiedHash":"7cdd30849e24f458a1ad090c39562fc1","fileName":"/ICSME-replicationpackage/dataset/smelly_dockerfiles_bianncle/0cd5356faf1139a632964ad22ef7273dc0f7e17e.dockerfile"}