{"seed":3433912616,"processedDockerfileHash":"0799d6f0502a38a5e22688dbcc6a7b2b","fixedSmells":["use-no-install-recommends","do-not-use-apt-get-update-alone","pin-package-manager-versions-apt-get","pin-package-manager-versions-pip","pin-package-manager-versions-npm","pin-package-manager-versions-gem","pin-package-manager-versions-apk","use-copy-instead-of-add","use-wget-instead-of-add","do-not-have-secrets","have-a-healthcheck","have-a-user"],"successfullyFixedSmells":["pin-package-manager-versions-apt-get","have-a-healthcheck","have-a-user"],"processedDockerfile":"FROM debian:stretch AS stage_build\n#   ------------------------------ ABOUT THIS IMAGE  -----------------------------\n#   This Dockerfile has two major sections:\n#   * STAGE BUILD: Which uses required tools to build a static version of Emscripten SDK\n#   * STAGE DEPLOY: Which copies folder of Emscripten (/emsd_portable) from previous stage, and installs very based tools to make Emscripten work.\n#\n#   Compiled Emscripten SDK meant to be ready to go out of the shelf. That is `/emsdk_portable`:\n#   - contains every required part of Emscripten SDK\n#   - contains entrypoint that should be used for derived images\n#   - is able to work with further changes coming from SDK updates (`emsdk install ...`, etc)\n#   - contains some useful symbolic links that makes sure you can use Emscripten SDK in the same way, regardless of version that it holds\n#   Created symbolic links:\n#   - `/emsdk_portable/emscripten/sdk`: Points to folder that holds Emscripten SDK tools like `emcc`, (example: `/emsdk_portable/emscripten/tag-1.38.31`)\n#   - `/emsdk_portable/binaryen/bin`: (example: `/emsdk_portable/tag-1.38.31_64bit_binaryen/bin`)\n#   - `/emsdk_portable/llvm/clang`: Emscripten version of Clang (example: `/emsdk_portable/clang/tag-1.38.31/build_tag-1.38.31_64`)\n#   - `/emsdk_portable/node/current`: Embedded version of NodeJS (example: `/emsdk_portable/node/8.9.1_64bit`)\n#   ------------------------------------------------------------------------------\n#   -------------------------------- STAGE BUILD  --------------------------------\n#   ------------------------------------------------------------------------------\nARG EMSCRIPTEN_SDK=sdk-tag-1.37.16-64bit\nARG EMSDK_CHANGESET=master\n#   ------------------------------------------------------------------------------\n#   Following variables are important to tell Emscripten to use pre-defined locations\n#   for loading config file and place cache files. Otherwise SDK will use own folders under `/root/` folder\nENV EMSDK=\"/emsdk_portable\"\nENV EM_DATA=\"${EMSDK}/.data\"\nENV EM_CONFIG=\"${EMSDK}/.emscripten\"\nENV EM_CACHE=\"${EM_DATA}/cache\"\nENV EM_PORTS=\"${EM_DATA}/ports\"\n#   ------------------------------------------------------------------------------\nRUN echo \"## Update and install packages\" \\\n && apt-get update -qq -y \\\n && apt-get install --no-install-recommends wget=1.18-5+deb9u3 git-core=1:2.11.0-3+deb9u7 ca-certificates=20200601~deb9u2 build-essential=12.3 file=1:5.30-1+deb9u3 python=2.7.13-2 python-pip=9.0.1-2+deb9u2 -qq -y \\\n && echo \"## Done\"\nRUN echo \"## Installing CMake\" \\\n && wget https://cmake.org/files/v3.6/cmake-3.6.3-Linux-x86_64.sh -q \\\n && mkdir /opt/cmake \\\n && printf \"y\\nn\\n\" | sh cmake-3.6.3-Linux-x86_64.sh --prefix=/opt/cmake > /dev/null \\\n && ln -s /opt/cmake/bin/cmake /usr/local/bin/cmake \\\n && echo \"## Done\"\nRUN echo \"## Get EMSDK\" \\\n && git clone https://github.com/juj/emsdk.git ${EMSDK} \\\n && cd ${EMSDK} \\\n && git reset --hard ${EMSDK_CHANGESET} \\\n && echo ${EMSCRIPTEN_SDK} | sed 's/.\\+-\\([0-9]\\+\\.[0-9]\\+\\.[0-9]\\+\\).\\+/\\1/g' > emscripten-tags.txt \\\n && echo \"## Done\"\nRUN echo \"## Compile Emscripten\" \\\n && cd ${EMSDK} \\\n && ./emsdk install node-8.9.1-64bit > /dev/null \\\n && LLVM_CMAKE_ARGS=-DLLVM_LINK_LLVM_DYLIB=ON,-DLLVM_LINK_LLVM_DYLIB=ON ./emsdk install --build=MinSizeRel ${EMSCRIPTEN_SDK} \\\n && echo \"## Done\"\n#   This generates configuration that contains all valid paths according to installed SDK\nRUN cd ${EMSDK} \\\n && echo \"## Generate standard configuration\" \\\n && ./emsdk activate ${EMSCRIPTEN_SDK} --embedded \\\n && ./emsdk construct_env > /dev/null \\\n && sed -i -e \"/EM_CACHE/d\" ${EMSDK}/emsdk_set_env.sh \\\n && echo \"## Done\"\n#   Create a structure and make mutable folders accessible for r/w\nRUN cd ${EMSDK} \\\n && echo \"## Create .data structure\" \\\n && for mutable_dir in ${EM_DATA} ${EM_PORTS} ${EM_CACHE} ${EMSDK}/zips ${EMSDK}/tmp; do mkdir -p ${mutable_dir} ;chmod -R 777 ${mutable_dir} ; done \\\n && echo \"## Done\"\n#   Step uses some bashizm\nSHELL [\"/bin/bash\", \"-c\"]\nRUN cd ${EMSDK} \\\n && echo \"## Clean-up Emscripten Installation\" \\\n && shopt -s globstar \\\n && _file=`echo ./emscripten/*/site/build/text/docs/tools_reference/emcc.txt ` \\\n && _content=`cat ${_file} ` \\\n && rm -fr ./emscripten/*/docs ./emscripten/*/media ./emscripten/*/site \\\n && mkdir -p `dirname ${_file} ` \\\n && echo ${_content} >> ${_file} \\\n && _file=`echo clang/*/src/emscripten-version.txt ` \\\n && _content=`cat ${_file} ` \\\n && rm -fr clang/*/src \\\n && mkdir -p `dirname ${_file} ` \\\n && echo ${_content} >> ${_file} \\\n && rm -fr binaryen/*/src \\\n && rm -fr binaryen/**/test \\\n && rm -fr binaryen/**/*.cmake \\\n && rm -fr binaryen/**/Makefile \\\n && rm -fr clang/*/*/docs \\\n && rm -fr clang/*/*/tools \\\n && rm -fr clang/*/*/projects \\\n && rm -fr clang/*/*/cmake \\\n && rm -fr clang/**/*.cmake \\\n && rm -fr clang/**/Makefile \\\n && find . -name \"*.pyc\" -exec rm {}\nRUN apt-get update -qq -y \\\n && apt-get install --no-install-recommends binutils=2.28-5 -qq -y \\\n && . ${EMSDK}/emsdk_set_env.sh \\\n && strip -s `which node ` \\\n && find $( dirname $( which clang-6.0 ;) ;) -type f -exec strip -s {} + || true \\\n && echo \"## Done\"\n#   ------------------------------------------------------------------------------\nRUN echo \"## Create transferable entrypoint\" \\\n && printf '#!/bin/sh\\n' > ${EMSDK}/entrypoint \\\n && printf 'if [ \"$HOME\" = \"/\" ] ; then\\n' >> ${EMSDK}/entrypoint \\\n && printf ' export HOME=/tmp\\n' >> ${EMSDK}/entrypoint \\\n && printf 'fi\\n' >> ${EMSDK}/entrypoint \\\n && printf '\\n' >> ${EMSDK}/entrypoint \\\n && printf 'if [ \"$(id -g)\" = \"0\" ] \\\n && [ \"$(id -u)\" = \"0\" ] ;\\n' >> ${EMSDK}/entrypoint \\\n && printf 'then\\n' >> ${EMSDK}/entrypoint \\\n && printf ' umask 0000\\n' >> ${EMSDK}/entrypoint \\\n && printf 'fi\\n' >> ${EMSDK}/entrypoint \\\n && printf \"export EMSDK=${EMSDK}\\n\" >> ${EMSDK}/entrypoint \\\n && printf \"export EM_DATA=${EM_DATA}\\n\" >> ${EMSDK}/entrypoint \\\n && printf \"export EM_CONFIG=${EM_CONFIG}\\n\" >> ${EMSDK}/entrypoint \\\n && printf \"export EM_CACHE=${EM_CACHE}\\n\" >> ${EMSDK}/entrypoint \\\n && printf \"export EM_PORTS=${EM_PORTS}\\n\" >> ${EMSDK}/entrypoint \\\n && printf '. ${EMSDK}/emsdk_set_env.sh > /dev/null\\n' >> ${EMSDK}/entrypoint \\\n && printf '\"$@\"\\n' >> ${EMSDK}/entrypoint \\\n && chmod +x ${EMSDK}/entrypoint \\\n && echo \"## Done\"\n#   Populate Emscripten SDK cache with libc++, to improve further compilation times.\nRUN echo \"## Pre-populate cache\" \\\n && . ${EMSDK}/emsdk_set_env.sh \\\n && mkdir -p /tmp/emscripten_test \\\n && cd /tmp/emscripten_test \\\n && printf '#include <iostream>\\nint main(){std::cout << \"HELLO FROM DOCKER C++\"<<std::endl;return 0;}' > test.cpp \\\n && em++ --std=c++11 test.cpp -o test.js -s WASM=0 \\\n && node test.js \\\n && em++ --std=c++11 -g4 test.cpp -o test.js -s WASM=0 \\\n && node test.js \\\n && em++ --std=c++11 test.cpp -o test.js -s WASM=1 \\\n && node test.js \\\n && cd / \\\n && rm -fr /tmp/emscripten_test \\\n && chmod -R 777 ${EM_DATA} \\\n && find ${EMSDK} -name \"*.pyc\" -exec rm {}\n#   Create symbolic links for critical Emscripten Tools\n#   This is important for letting people using Emscripten in Dockerfiles without activation\n#   As each Emscripten release is placed to a different folder (i.e. /emsdk_portable/emscripten/tag-1.38.31)\n#   We need to somehow make it fixed. An old solution was to move folders around but it has some drawbacks.\n#   Current solution is to create symlinks that matches old solution: which maintains compatibility\n#   The ultimate goal is to simplify a way to use Emscripten SDK without a need to activate it.\nRUN echo \"## Create symbolic links\" \\\n && . ${EMSDK}/emsdk_set_env.sh \\\n && mkdir -p ${EMSDK}/llvm \\\n && ln -s $( dirname $( which node ;) ;)/.. ${EMSDK}/node/current \\\n && ln -s $( dirname $( which clang ;) ;)/.. ${EMSDK}/llvm/clang \\\n && ln -s $( dirname $( which emcc ;) ;) ${EMSDK}/emscripten/sdk \\\n && ln -s $( dirname $( which asm2wasm ;) ;) ${EMSDK}/binaryen/bin \\\n && echo \"## Done\"\n#   ------------------------------------------------------------------------------\n#   -------------------------------- STAGE DEPLOY --------------------------------\n#   ------------------------------------------------------------------------------\nFROM debian:stretch-slim AS stage_deploy\nCOPY --from=stage_build /emsdk_portable /emsdk_portable\n#   Fallback in case Emscripten isn't activated.\n#   This will let use tools offered by this image inside other Docker images (sub-stages) or with custom / no entrypoint\nENV EMSDK=\"/emsdk_portable\"\nENV EMSCRIPTEN=\"${EMSDK}/emscripten/sdk\"\nENV EM_DATA=\"${EMSDK}/.data\"\nENV EM_CONFIG=\"${EMSDK}/.emscripten\"\nENV EM_CACHE=\"${EM_DATA}/cache\"\nENV EM_PORTS=\"${EM_DATA}/ports\"\n#   Fallback in case Emscripten isn't activated\n#   Expose Major tools to system PATH, so that emcc, node, asm2wasm etc can be used without activation\nENV PATH=\"${EMSDK}:${EMSDK}/emscripten/sdk:${EMSDK}/llvm/clang/bin:${EMSDK}/node/current/bin:${EMSDK}/binaryen/bin:${PATH}\"\n#   Use entrypoint that's coming from emscripten-slim image. It sets all required system paths and variables\nENTRYPOINT [\"/emsdk_portable/entrypoint\"]\n#   ------------------------------------------------------------------------------\n#   Create a 'standard` 1000:1000 user\n#   Thanks to that this image can be executed as non-root user and created files will not require root access level on host machine\n#   Please note that this solution even if widely spread (even node Dockerimages use that) is far from perfect as user 1000:1000 might not exist on\n#   host machine, and in this case running any docker image will cause other random problems (mostly due `$HOME` pointing to `/`)\n#   This extra user works nicely with entrypoint provided in `/emsdk_portable/entrypoint` as it detects case explained before.\nRUN echo \"## Create emscripten user (1000:1000)\" \\\n && groupadd --gid 1000 emscripten \\\n && useradd --uid 1000 --gid emscripten --shell /bin/bash --create-home emscripten \\\n && echo \"## Done\"\nRUN echo \"## Update and install packages\" \\\n && apt-get update -qq -y \\\n && apt-get install --no-install-recommends ca-certificates=20200601~deb9u2 python=2.7.13-2 python-pip=9.0.1-2+deb9u2 -qq -y \\\n && apt-get -y clean \\\n && apt-get -y autoclean \\\n && apt-get -y autoremove \\\n && rm -rf /var/lib/apt/lists/* \\\n && rm -rf /var/cache/debconf/*-old \\\n && rm -rf /usr/share/doc/* \\\n && rm -rf /usr/share/man/?? \\\n && rm -rf /usr/share/man/??_* \\\n && echo \"## Done\"\n#   Docker's convention is to create entrypoint in /entrypoint path.\n#   Let's create this entrypoint for compatibility and to keep tradition, which forward command to the real entrypoint\n#   Main intentions is to keep compatibility with previous images\nRUN echo \"## Create standard docker entrypoint\" \\\n && printf '#!/bin/bash\\n' > /entrypoint \\\n && printf \". ${EMSDK}/entrypoint \\\"$@\\\"\\n\" >> /entrypoint \\\n && chmod +x /entrypoint \\\n && echo \"## Done\"\n#   Arbitrary folder, nothing special here\nWORKDIR /src\n#   ------------------------------------------------------------------------------\n#   Copy this Dockerimage into image, so that it will be possible to recreate it later\nCOPY Dockerfile /emsdk_portable/dockerfiles/trzeci/emscripten-slim/\nLABEL maintainer=\"kontakt@trzeci.eu\" \\\n      org.label-schema.name=\"emscripten-slim\" \\\n      org.label-schema.description=\"This image includes EMSDK, Emscripten and WebAssembly compiler and tools that are very required to compile sources.\" \\\n      org.label-schema.url=\"https://trzeci.eu\" \\\n      org.label-schema.vcs-url=\"https://github.com/trzecieu/emscripten-docker\" \\\n      org.label-schema.docker.dockerfile=\"/docker/trzeci/emscripten-slim/Dockerfile\"\n#   ------------------------- POST BUILD IN-PLACE TESTING ------------------------\nRUN echo \"## Internal Testing of image (activated)\" \\\n && . ${EMSDK}/emsdk_set_env.sh \\\n && set -x \\\n && which asm2wasm \\\n && which llvm-ar \\\n && which emsdk \\\n && node --version \\\n && npm --version \\\n && python --version \\\n && pip --version \\\n && em++ --version \\\n && emcc --version \\\n && find ${EMSDK} -name \"*.pyc\" -exec rm {}\nRUN echo \"## Internal Testing of image (no activation)\" \\\n && set -x \\\n && which asm2wasm \\\n && which llvm-ar \\\n && which emsdk \\\n && node --version \\\n && npm --version \\\n && python --version \\\n && pip --version \\\n && em++ --version \\\n && emcc --version \\\n && find ${EMSDK} -name \"*.pyc\" -exec rm {}\n#   ------------------------------------------------------------------------------\nRUN groupadd --system docker-user ; useradd --system --gid docker-user docker-user\nUSER docker-user\n# Please add your HEALTHCHECK here!!!\n","originalDockerfile":"FROM debian:stretch AS stage_build\n#  ------------------------------ ABOUT THIS IMAGE  -----------------------------\n#  This Dockerfile has two major sections:\n#  * STAGE BUILD: Which uses required tools to build a static version of Emscripten SDK\n#  * STAGE DEPLOY: Which copies folder of Emscripten (/emsd_portable) from previous stage, and installs very based tools to make Emscripten work.\n#\n#  Compiled Emscripten SDK meant to be ready to go out of the shelf. That is `/emsdk_portable`:\n#  - contains every required part of Emscripten SDK\n#  - contains entrypoint that should be used for derived images\n#  - is able to work with further changes coming from SDK updates (`emsdk install ...`, etc)\n#  - contains some useful symbolic links that makes sure you can use Emscripten SDK in the same way, regardless of version that it holds\n#  Created symbolic links:\n#  - `/emsdk_portable/emscripten/sdk`: Points to folder that holds Emscripten SDK tools like `emcc`, (example: `/emsdk_portable/emscripten/tag-1.38.31`)\n#  - `/emsdk_portable/binaryen/bin`: (example: `/emsdk_portable/tag-1.38.31_64bit_binaryen/bin`)\n#  - `/emsdk_portable/llvm/clang`: Emscripten version of Clang (example: `/emsdk_portable/clang/tag-1.38.31/build_tag-1.38.31_64`)\n#  - `/emsdk_portable/node/current`: Embedded version of NodeJS (example: `/emsdk_portable/node/8.9.1_64bit`)\n#  ------------------------------------------------------------------------------\n#  -------------------------------- STAGE BUILD  --------------------------------\n#  ------------------------------------------------------------------------------\nARG EMSCRIPTEN_SDK=sdk-tag-1.37.16-64bit\nARG EMSDK_CHANGESET=master\n#  ------------------------------------------------------------------------------\n#  Following variables are important to tell Emscripten to use pre-defined locations\n#  for loading config file and place cache files. Otherwise SDK will use own folders under `/root/` folder\nENV EMSDK=\"/emsdk_portable\"\nENV EM_DATA=\"${EMSDK}/.data\"\nENV EM_CONFIG=\"${EMSDK}/.emscripten\"\nENV EM_CACHE=\"${EM_DATA}/cache\"\nENV EM_PORTS=\"${EM_DATA}/ports\"\n#  ------------------------------------------------------------------------------\nRUN echo \"## Update and install packages\" \\\n && apt-get update -qq -y \\\n && apt-get install --no-install-recommends wget git-core ca-certificates build-essential file python python-pip -qq -y \\\n && echo \"## Done\"\nRUN echo \"## Installing CMake\" \\\n && wget https://cmake.org/files/v3.6/cmake-3.6.3-Linux-x86_64.sh -q \\\n && mkdir /opt/cmake \\\n && printf \"y\\nn\\n\" | sh cmake-3.6.3-Linux-x86_64.sh --prefix=/opt/cmake > /dev/null \\\n && ln -s /opt/cmake/bin/cmake /usr/local/bin/cmake \\\n && echo \"## Done\"\nRUN echo \"## Get EMSDK\" \\\n && git clone https://github.com/juj/emsdk.git ${EMSDK} \\\n && cd ${EMSDK} \\\n && git reset --hard ${EMSDK_CHANGESET} \\\n && echo ${EMSCRIPTEN_SDK} | sed 's/.\\+-\\([0-9]\\+\\.[0-9]\\+\\.[0-9]\\+\\).\\+/\\1/g' > emscripten-tags.txt \\\n && echo \"## Done\"\nRUN echo \"## Compile Emscripten\" \\\n && cd ${EMSDK} \\\n && ./emsdk install node-8.9.1-64bit > /dev/null \\\n && LLVM_CMAKE_ARGS=-DLLVM_LINK_LLVM_DYLIB=ON,-DLLVM_LINK_LLVM_DYLIB=ON ./emsdk install --build=MinSizeRel ${EMSCRIPTEN_SDK} \\\n && echo \"## Done\"\n#  This generates configuration that contains all valid paths according to installed SDK\nRUN cd ${EMSDK} \\\n && echo \"## Generate standard configuration\" \\\n && ./emsdk activate ${EMSCRIPTEN_SDK} --embedded \\\n && ./emsdk construct_env > /dev/null \\\n && sed -i -e \"/EM_CACHE/d\" ${EMSDK}/emsdk_set_env.sh \\\n && echo \"## Done\"\n#  Create a structure and make mutable folders accessible for r/w\nRUN cd ${EMSDK} \\\n && echo \"## Create .data structure\" \\\n && for mutable_dir in ${EM_DATA} ${EM_PORTS} ${EM_CACHE} ${EMSDK}/zips ${EMSDK}/tmp; do mkdir -p ${mutable_dir} ;chmod -R 777 ${mutable_dir} ; done \\\n && echo \"## Done\"\n#  Step uses some bashizm\nSHELL [\"/bin/bash\", \"-c\"]\nRUN cd ${EMSDK} \\\n && echo \"## Clean-up Emscripten Installation\" \\\n && shopt -s globstar \\\n && _file=`echo ./emscripten/*/site/build/text/docs/tools_reference/emcc.txt ` \\\n && _content=`cat ${_file} ` \\\n && rm -fr ./emscripten/*/docs ./emscripten/*/media ./emscripten/*/site \\\n && mkdir -p `dirname ${_file} ` \\\n && echo ${_content} >> ${_file} \\\n && _file=`echo clang/*/src/emscripten-version.txt ` \\\n && _content=`cat ${_file} ` \\\n && rm -fr clang/*/src \\\n && mkdir -p `dirname ${_file} ` \\\n && echo ${_content} >> ${_file} \\\n && rm -fr binaryen/*/src \\\n && rm -fr binaryen/**/test \\\n && rm -fr binaryen/**/*.cmake \\\n && rm -fr binaryen/**/Makefile \\\n && rm -fr clang/*/*/docs \\\n && rm -fr clang/*/*/tools \\\n && rm -fr clang/*/*/projects \\\n && rm -fr clang/*/*/cmake \\\n && rm -fr clang/**/*.cmake \\\n && rm -fr clang/**/Makefile \\\n && find . -name \"*.pyc\" -exec rm {} ; \\\n && find . -name \"CMakeFiles\" -type d -prune -exec rm -fr {} ; \\\n && find . -name \"CMakeCache.txt\" -exec rm {} ; \\\n && find . -name \"*.o\" -exec rm {} ; \\\n && find . -name \"*.a\" -exec rm {} ; \\\n && find . -name \"*.inc*\" -exec rm {} ; \\\n && find . -name \"*.gen.tmp\" -exec rm {} ; \\\n && find clang -type d -depth -empty -exec rmdir \"{}\" ; \\\n && find binaryen -type d -depth -empty -exec rmdir \"{}\" ; \\\n && rm -fr **/*_32bit \\\n && rm -rf **/.git \\\n && rm -rf **/tests \\\n && rm -fr zips/* \\\n && rm -fr /opt/cmake /usr/local/bin/cmake /cmake* \\\n && sleep 2 \\\n && echo \"## Done\"\nRUN apt-get update -qq -y \\\n && apt-get install --no-install-recommends binutils -qq -y \\\n && . ${EMSDK}/emsdk_set_env.sh \\\n && strip -s `which node ` \\\n && find $( dirname $( which clang-6.0 ;) ;) -type f -exec strip -s {} + || true \\\n && echo \"## Done\"\n#  ------------------------------------------------------------------------------\nRUN echo \"## Create transferable entrypoint\" \\\n && printf '#!/bin/sh\\n' > ${EMSDK}/entrypoint \\\n && printf 'if [ \"$HOME\" = \"/\" ] ; then\\n' >> ${EMSDK}/entrypoint \\\n && printf ' export HOME=/tmp\\n' >> ${EMSDK}/entrypoint \\\n && printf 'fi\\n' >> ${EMSDK}/entrypoint \\\n && printf '\\n' >> ${EMSDK}/entrypoint \\\n && printf 'if [ \"$(id -g)\" = \"0\" ] \\\n && [ \"$(id -u)\" = \"0\" ] ;\\n' >> ${EMSDK}/entrypoint \\\n && printf 'then\\n' >> ${EMSDK}/entrypoint \\\n && printf ' umask 0000\\n' >> ${EMSDK}/entrypoint \\\n && printf 'fi\\n' >> ${EMSDK}/entrypoint \\\n && printf \"export EMSDK=${EMSDK}\\n\" >> ${EMSDK}/entrypoint \\\n && printf \"export EM_DATA=${EM_DATA}\\n\" >> ${EMSDK}/entrypoint \\\n && printf \"export EM_CONFIG=${EM_CONFIG}\\n\" >> ${EMSDK}/entrypoint \\\n && printf \"export EM_CACHE=${EM_CACHE}\\n\" >> ${EMSDK}/entrypoint \\\n && printf \"export EM_PORTS=${EM_PORTS}\\n\" >> ${EMSDK}/entrypoint \\\n && printf '. ${EMSDK}/emsdk_set_env.sh > /dev/null\\n' >> ${EMSDK}/entrypoint \\\n && printf '\"$@\"\\n' >> ${EMSDK}/entrypoint \\\n && chmod +x ${EMSDK}/entrypoint \\\n && echo \"## Done\"\n#  Populate Emscripten SDK cache with libc++, to improve further compilation times.\nRUN echo \"## Pre-populate cache\" \\\n && . ${EMSDK}/emsdk_set_env.sh \\\n && mkdir -p /tmp/emscripten_test \\\n && cd /tmp/emscripten_test \\\n && printf '#include <iostream>\\nint main(){std::cout << \"HELLO FROM DOCKER C++\"<<std::endl;return 0;}' > test.cpp \\\n && em++ --std=c++11 test.cpp -o test.js -s WASM=0 \\\n && node test.js \\\n && em++ --std=c++11 -g4 test.cpp -o test.js -s WASM=0 \\\n && node test.js \\\n && em++ --std=c++11 test.cpp -o test.js -s WASM=1 \\\n && node test.js \\\n && cd / \\\n && rm -fr /tmp/emscripten_test \\\n && chmod -R 777 ${EM_DATA} \\\n && find ${EMSDK} -name \"*.pyc\" -exec rm {} ; \\\n && echo \"## Done\"\n#  Create symbolic links for critical Emscripten Tools\n#  This is important for letting people using Emscripten in Dockerfiles without activation\n#  As each Emscripten release is placed to a different folder (i.e. /emsdk_portable/emscripten/tag-1.38.31)\n#  We need to somehow make it fixed. An old solution was to move folders around but it has some drawbacks.\n#  Current solution is to create symlinks that matches old solution: which maintains compatibility\n#  The ultimate goal is to simplify a way to use Emscripten SDK without a need to activate it.\nRUN echo \"## Create symbolic links\" \\\n && . ${EMSDK}/emsdk_set_env.sh \\\n && mkdir -p ${EMSDK}/llvm \\\n && ln -s $( dirname $( which node ;) ;)/.. ${EMSDK}/node/current \\\n && ln -s $( dirname $( which clang ;) ;)/.. ${EMSDK}/llvm/clang \\\n && ln -s $( dirname $( which emcc ;) ;) ${EMSDK}/emscripten/sdk \\\n && ln -s $( dirname $( which asm2wasm ;) ;) ${EMSDK}/binaryen/bin \\\n && echo \"## Done\"\n#  ------------------------------------------------------------------------------\n#  -------------------------------- STAGE DEPLOY --------------------------------\n#  ------------------------------------------------------------------------------\nFROM debian:stretch-slim AS stage_deploy\nCOPY --from=stage_build /emsdk_portable /emsdk_portable\n#  Fallback in case Emscripten isn't activated.\n#  This will let use tools offered by this image inside other Docker images (sub-stages) or with custom / no entrypoint\nENV EMSDK=\"/emsdk_portable\"\nENV EMSCRIPTEN=\"${EMSDK}/emscripten/sdk\"\nENV EM_DATA=\"${EMSDK}/.data\"\nENV EM_CONFIG=\"${EMSDK}/.emscripten\"\nENV EM_CACHE=\"${EM_DATA}/cache\"\nENV EM_PORTS=\"${EM_DATA}/ports\"\n#  Fallback in case Emscripten isn't activated\n#  Expose Major tools to system PATH, so that emcc, node, asm2wasm etc can be used without activation\nENV PATH=\"${EMSDK}:${EMSDK}/emscripten/sdk:${EMSDK}/llvm/clang/bin:${EMSDK}/node/current/bin:${EMSDK}/binaryen/bin:${PATH}\"\n#  Use entrypoint that's coming from emscripten-slim image. It sets all required system paths and variables\nENTRYPOINT [\"/emsdk_portable/entrypoint\"]\n#  ------------------------------------------------------------------------------\n#  Create a 'standard` 1000:1000 user\n#  Thanks to that this image can be executed as non-root user and created files will not require root access level on host machine\n#  Please note that this solution even if widely spread (even node Dockerimages use that) is far from perfect as user 1000:1000 might not exist on\n#  host machine, and in this case running any docker image will cause other random problems (mostly due `$HOME` pointing to `/`)\n#  This extra user works nicely with entrypoint provided in `/emsdk_portable/entrypoint` as it detects case explained before.\nRUN echo \"## Create emscripten user (1000:1000)\" \\\n && groupadd --gid 1000 emscripten \\\n && useradd --uid 1000 --gid emscripten --shell /bin/bash --create-home emscripten \\\n && echo \"## Done\"\nRUN echo \"## Update and install packages\" \\\n && apt-get update -qq -y \\\n && apt-get install --no-install-recommends ca-certificates python python-pip -qq -y \\\n && apt-get -y clean \\\n && apt-get -y autoclean \\\n && apt-get -y autoremove \\\n && rm -rf /var/lib/apt/lists/* \\\n && rm -rf /var/cache/debconf/*-old \\\n && rm -rf /usr/share/doc/* \\\n && rm -rf /usr/share/man/?? \\\n && rm -rf /usr/share/man/??_* \\\n && echo \"## Done\"\n#  Docker's convention is to create entrypoint in /entrypoint path.\n#  Let's create this entrypoint for compatibility and to keep tradition, which forward command to the real entrypoint\n#  Main intentions is to keep compatibility with previous images\nRUN echo \"## Create standard docker entrypoint\" \\\n && printf '#!/bin/bash\\n' > /entrypoint \\\n && printf \". ${EMSDK}/entrypoint \\\"$@\\\"\\n\" >> /entrypoint \\\n && chmod +x /entrypoint \\\n && echo \"## Done\"\n#  Arbitrary folder, nothing special here\nWORKDIR /src\n#  ------------------------------------------------------------------------------\n#  Copy this Dockerimage into image, so that it will be possible to recreate it later\nCOPY Dockerfile /emsdk_portable/dockerfiles/trzeci/emscripten-slim/\nLABEL maintainer=\"kontakt@trzeci.eu\" \\\n      org.label-schema.name=\"emscripten-slim\" \\\n      org.label-schema.description=\"This image includes EMSDK, Emscripten and WebAssembly compiler and tools that are very required to compile sources.\" \\\n      org.label-schema.url=\"https://trzeci.eu\" \\\n      org.label-schema.vcs-url=\"https://github.com/trzecieu/emscripten-docker\" \\\n      org.label-schema.docker.dockerfile=\"/docker/trzeci/emscripten-slim/Dockerfile\"\n#  ------------------------- POST BUILD IN-PLACE TESTING ------------------------\nRUN echo \"## Internal Testing of image (activated)\" \\\n && . ${EMSDK}/emsdk_set_env.sh \\\n && set -x \\\n && which asm2wasm \\\n && which llvm-ar \\\n && which emsdk \\\n && node --version \\\n && npm --version \\\n && python --version \\\n && pip --version \\\n && em++ --version \\\n && emcc --version \\\n && find ${EMSDK} -name \"*.pyc\" -exec rm {} ; \\\n && echo \"## Done\"\nRUN echo \"## Internal Testing of image (no activation)\" \\\n && set -x \\\n && which asm2wasm \\\n && which llvm-ar \\\n && which emsdk \\\n && node --version \\\n && npm --version \\\n && python --version \\\n && pip --version \\\n && em++ --version \\\n && emcc --version \\\n && find ${EMSDK} -name \"*.pyc\" -exec rm {} ; \\\n && echo \"## Done\"\n#  ------------------------------------------------------------------------------\n","injectedSmells":[],"originalDockerfileHash":"cdf5de733ec3ffb753b6dd9cccad5928","successfullyInjectedSmells":[],"originalDockerfileUglified":"FROM debian:stretch AS stage_build\n#   ------------------------------ ABOUT THIS IMAGE  -----------------------------\n#   This Dockerfile has two major sections:\n#   * STAGE BUILD: Which uses required tools to build a static version of Emscripten SDK\n#   * STAGE DEPLOY: Which copies folder of Emscripten (/emsd_portable) from previous stage, and installs very based tools to make Emscripten work.\n#\n#   Compiled Emscripten SDK meant to be ready to go out of the shelf. That is `/emsdk_portable`:\n#   - contains every required part of Emscripten SDK\n#   - contains entrypoint that should be used for derived images\n#   - is able to work with further changes coming from SDK updates (`emsdk install ...`, etc)\n#   - contains some useful symbolic links that makes sure you can use Emscripten SDK in the same way, regardless of version that it holds\n#   Created symbolic links:\n#   - `/emsdk_portable/emscripten/sdk`: Points to folder that holds Emscripten SDK tools like `emcc`, (example: `/emsdk_portable/emscripten/tag-1.38.31`)\n#   - `/emsdk_portable/binaryen/bin`: (example: `/emsdk_portable/tag-1.38.31_64bit_binaryen/bin`)\n#   - `/emsdk_portable/llvm/clang`: Emscripten version of Clang (example: `/emsdk_portable/clang/tag-1.38.31/build_tag-1.38.31_64`)\n#   - `/emsdk_portable/node/current`: Embedded version of NodeJS (example: `/emsdk_portable/node/8.9.1_64bit`)\n#   ------------------------------------------------------------------------------\n#   -------------------------------- STAGE BUILD  --------------------------------\n#   ------------------------------------------------------------------------------\nARG EMSCRIPTEN_SDK=sdk-tag-1.37.16-64bit\nARG EMSDK_CHANGESET=master\n#   ------------------------------------------------------------------------------\n#   Following variables are important to tell Emscripten to use pre-defined locations\n#   for loading config file and place cache files. Otherwise SDK will use own folders under `/root/` folder\nENV EMSDK=\"/emsdk_portable\"\nENV EM_DATA=\"${EMSDK}/.data\"\nENV EM_CONFIG=\"${EMSDK}/.emscripten\"\nENV EM_CACHE=\"${EM_DATA}/cache\"\nENV EM_PORTS=\"${EM_DATA}/ports\"\n#   ------------------------------------------------------------------------------\nRUN echo \"## Update and install packages\" \\\n && apt-get update -qq -y \\\n && apt-get install --no-install-recommends wget git-core ca-certificates build-essential file python python-pip -qq -y \\\n && echo \"## Done\"\nRUN echo \"## Installing CMake\" \\\n && wget https://cmake.org/files/v3.6/cmake-3.6.3-Linux-x86_64.sh -q \\\n && mkdir /opt/cmake \\\n && printf \"y\\nn\\n\" | sh cmake-3.6.3-Linux-x86_64.sh --prefix=/opt/cmake > /dev/null \\\n && ln -s /opt/cmake/bin/cmake /usr/local/bin/cmake \\\n && echo \"## Done\"\nRUN echo \"## Get EMSDK\" \\\n && git clone https://github.com/juj/emsdk.git ${EMSDK} \\\n && cd ${EMSDK} \\\n && git reset --hard ${EMSDK_CHANGESET} \\\n && echo ${EMSCRIPTEN_SDK} | sed 's/.\\+-\\([0-9]\\+\\.[0-9]\\+\\.[0-9]\\+\\).\\+/\\1/g' > emscripten-tags.txt \\\n && echo \"## Done\"\nRUN echo \"## Compile Emscripten\" \\\n && cd ${EMSDK} \\\n && ./emsdk install node-8.9.1-64bit > /dev/null \\\n && LLVM_CMAKE_ARGS=-DLLVM_LINK_LLVM_DYLIB=ON,-DLLVM_LINK_LLVM_DYLIB=ON ./emsdk install --build=MinSizeRel ${EMSCRIPTEN_SDK} \\\n && echo \"## Done\"\n#   This generates configuration that contains all valid paths according to installed SDK\nRUN cd ${EMSDK} \\\n && echo \"## Generate standard configuration\" \\\n && ./emsdk activate ${EMSCRIPTEN_SDK} --embedded \\\n && ./emsdk construct_env > /dev/null \\\n && sed -i -e \"/EM_CACHE/d\" ${EMSDK}/emsdk_set_env.sh \\\n && echo \"## Done\"\n#   Create a structure and make mutable folders accessible for r/w\nRUN cd ${EMSDK} \\\n && echo \"## Create .data structure\" \\\n && for mutable_dir in ${EM_DATA} ${EM_PORTS} ${EM_CACHE} ${EMSDK}/zips ${EMSDK}/tmp; do mkdir -p ${mutable_dir} ;chmod -R 777 ${mutable_dir} ; done \\\n && echo \"## Done\"\n#   Step uses some bashizm\nSHELL [\"/bin/bash\", \"-c\"]\nRUN cd ${EMSDK} \\\n && echo \"## Clean-up Emscripten Installation\" \\\n && shopt -s globstar \\\n && _file=`echo ./emscripten/*/site/build/text/docs/tools_reference/emcc.txt ` \\\n && _content=`cat ${_file} ` \\\n && rm -fr ./emscripten/*/docs ./emscripten/*/media ./emscripten/*/site \\\n && mkdir -p `dirname ${_file} ` \\\n && echo ${_content} >> ${_file} \\\n && _file=`echo clang/*/src/emscripten-version.txt ` \\\n && _content=`cat ${_file} ` \\\n && rm -fr clang/*/src \\\n && mkdir -p `dirname ${_file} ` \\\n && echo ${_content} >> ${_file} \\\n && rm -fr binaryen/*/src \\\n && rm -fr binaryen/**/test \\\n && rm -fr binaryen/**/*.cmake \\\n && rm -fr binaryen/**/Makefile \\\n && rm -fr clang/*/*/docs \\\n && rm -fr clang/*/*/tools \\\n && rm -fr clang/*/*/projects \\\n && rm -fr clang/*/*/cmake \\\n && rm -fr clang/**/*.cmake \\\n && rm -fr clang/**/Makefile \\\n && find . -name \"*.pyc\" -exec rm {}\nRUN apt-get update -qq -y \\\n && apt-get install --no-install-recommends binutils -qq -y \\\n && . ${EMSDK}/emsdk_set_env.sh \\\n && strip -s `which node ` \\\n && find $( dirname $( which clang-6.0 ;) ;) -type f -exec strip -s {} + || true \\\n && echo \"## Done\"\n#   ------------------------------------------------------------------------------\nRUN echo \"## Create transferable entrypoint\" \\\n && printf '#!/bin/sh\\n' > ${EMSDK}/entrypoint \\\n && printf 'if [ \"$HOME\" = \"/\" ] ; then\\n' >> ${EMSDK}/entrypoint \\\n && printf ' export HOME=/tmp\\n' >> ${EMSDK}/entrypoint \\\n && printf 'fi\\n' >> ${EMSDK}/entrypoint \\\n && printf '\\n' >> ${EMSDK}/entrypoint \\\n && printf 'if [ \"$(id -g)\" = \"0\" ] \\\n && [ \"$(id -u)\" = \"0\" ] ;\\n' >> ${EMSDK}/entrypoint \\\n && printf 'then\\n' >> ${EMSDK}/entrypoint \\\n && printf ' umask 0000\\n' >> ${EMSDK}/entrypoint \\\n && printf 'fi\\n' >> ${EMSDK}/entrypoint \\\n && printf \"export EMSDK=${EMSDK}\\n\" >> ${EMSDK}/entrypoint \\\n && printf \"export EM_DATA=${EM_DATA}\\n\" >> ${EMSDK}/entrypoint \\\n && printf \"export EM_CONFIG=${EM_CONFIG}\\n\" >> ${EMSDK}/entrypoint \\\n && printf \"export EM_CACHE=${EM_CACHE}\\n\" >> ${EMSDK}/entrypoint \\\n && printf \"export EM_PORTS=${EM_PORTS}\\n\" >> ${EMSDK}/entrypoint \\\n && printf '. ${EMSDK}/emsdk_set_env.sh > /dev/null\\n' >> ${EMSDK}/entrypoint \\\n && printf '\"$@\"\\n' >> ${EMSDK}/entrypoint \\\n && chmod +x ${EMSDK}/entrypoint \\\n && echo \"## Done\"\n#   Populate Emscripten SDK cache with libc++, to improve further compilation times.\nRUN echo \"## Pre-populate cache\" \\\n && . ${EMSDK}/emsdk_set_env.sh \\\n && mkdir -p /tmp/emscripten_test \\\n && cd /tmp/emscripten_test \\\n && printf '#include <iostream>\\nint main(){std::cout << \"HELLO FROM DOCKER C++\"<<std::endl;return 0;}' > test.cpp \\\n && em++ --std=c++11 test.cpp -o test.js -s WASM=0 \\\n && node test.js \\\n && em++ --std=c++11 -g4 test.cpp -o test.js -s WASM=0 \\\n && node test.js \\\n && em++ --std=c++11 test.cpp -o test.js -s WASM=1 \\\n && node test.js \\\n && cd / \\\n && rm -fr /tmp/emscripten_test \\\n && chmod -R 777 ${EM_DATA} \\\n && find ${EMSDK} -name \"*.pyc\" -exec rm {}\n#   Create symbolic links for critical Emscripten Tools\n#   This is important for letting people using Emscripten in Dockerfiles without activation\n#   As each Emscripten release is placed to a different folder (i.e. /emsdk_portable/emscripten/tag-1.38.31)\n#   We need to somehow make it fixed. An old solution was to move folders around but it has some drawbacks.\n#   Current solution is to create symlinks that matches old solution: which maintains compatibility\n#   The ultimate goal is to simplify a way to use Emscripten SDK without a need to activate it.\nRUN echo \"## Create symbolic links\" \\\n && . ${EMSDK}/emsdk_set_env.sh \\\n && mkdir -p ${EMSDK}/llvm \\\n && ln -s $( dirname $( which node ;) ;)/.. ${EMSDK}/node/current \\\n && ln -s $( dirname $( which clang ;) ;)/.. ${EMSDK}/llvm/clang \\\n && ln -s $( dirname $( which emcc ;) ;) ${EMSDK}/emscripten/sdk \\\n && ln -s $( dirname $( which asm2wasm ;) ;) ${EMSDK}/binaryen/bin \\\n && echo \"## Done\"\n#   ------------------------------------------------------------------------------\n#   -------------------------------- STAGE DEPLOY --------------------------------\n#   ------------------------------------------------------------------------------\nFROM debian:stretch-slim AS stage_deploy\nCOPY --from=stage_build /emsdk_portable /emsdk_portable\n#   Fallback in case Emscripten isn't activated.\n#   This will let use tools offered by this image inside other Docker images (sub-stages) or with custom / no entrypoint\nENV EMSDK=\"/emsdk_portable\"\nENV EMSCRIPTEN=\"${EMSDK}/emscripten/sdk\"\nENV EM_DATA=\"${EMSDK}/.data\"\nENV EM_CONFIG=\"${EMSDK}/.emscripten\"\nENV EM_CACHE=\"${EM_DATA}/cache\"\nENV EM_PORTS=\"${EM_DATA}/ports\"\n#   Fallback in case Emscripten isn't activated\n#   Expose Major tools to system PATH, so that emcc, node, asm2wasm etc can be used without activation\nENV PATH=\"${EMSDK}:${EMSDK}/emscripten/sdk:${EMSDK}/llvm/clang/bin:${EMSDK}/node/current/bin:${EMSDK}/binaryen/bin:${PATH}\"\n#   Use entrypoint that's coming from emscripten-slim image. It sets all required system paths and variables\nENTRYPOINT [\"/emsdk_portable/entrypoint\"]\n#   ------------------------------------------------------------------------------\n#   Create a 'standard` 1000:1000 user\n#   Thanks to that this image can be executed as non-root user and created files will not require root access level on host machine\n#   Please note that this solution even if widely spread (even node Dockerimages use that) is far from perfect as user 1000:1000 might not exist on\n#   host machine, and in this case running any docker image will cause other random problems (mostly due `$HOME` pointing to `/`)\n#   This extra user works nicely with entrypoint provided in `/emsdk_portable/entrypoint` as it detects case explained before.\nRUN echo \"## Create emscripten user (1000:1000)\" \\\n && groupadd --gid 1000 emscripten \\\n && useradd --uid 1000 --gid emscripten --shell /bin/bash --create-home emscripten \\\n && echo \"## Done\"\nRUN echo \"## Update and install packages\" \\\n && apt-get update -qq -y \\\n && apt-get install --no-install-recommends ca-certificates python python-pip -qq -y \\\n && apt-get -y clean \\\n && apt-get -y autoclean \\\n && apt-get -y autoremove \\\n && rm -rf /var/lib/apt/lists/* \\\n && rm -rf /var/cache/debconf/*-old \\\n && rm -rf /usr/share/doc/* \\\n && rm -rf /usr/share/man/?? \\\n && rm -rf /usr/share/man/??_* \\\n && echo \"## Done\"\n#   Docker's convention is to create entrypoint in /entrypoint path.\n#   Let's create this entrypoint for compatibility and to keep tradition, which forward command to the real entrypoint\n#   Main intentions is to keep compatibility with previous images\nRUN echo \"## Create standard docker entrypoint\" \\\n && printf '#!/bin/bash\\n' > /entrypoint \\\n && printf \". ${EMSDK}/entrypoint \\\"$@\\\"\\n\" >> /entrypoint \\\n && chmod +x /entrypoint \\\n && echo \"## Done\"\n#   Arbitrary folder, nothing special here\nWORKDIR /src\n#   ------------------------------------------------------------------------------\n#   Copy this Dockerimage into image, so that it will be possible to recreate it later\nCOPY Dockerfile /emsdk_portable/dockerfiles/trzeci/emscripten-slim/\nLABEL maintainer=\"kontakt@trzeci.eu\" \\\n      org.label-schema.name=\"emscripten-slim\" \\\n      org.label-schema.description=\"This image includes EMSDK, Emscripten and WebAssembly compiler and tools that are very required to compile sources.\" \\\n      org.label-schema.url=\"https://trzeci.eu\" \\\n      org.label-schema.vcs-url=\"https://github.com/trzecieu/emscripten-docker\" \\\n      org.label-schema.docker.dockerfile=\"/docker/trzeci/emscripten-slim/Dockerfile\"\n#   ------------------------- POST BUILD IN-PLACE TESTING ------------------------\nRUN echo \"## Internal Testing of image (activated)\" \\\n && . ${EMSDK}/emsdk_set_env.sh \\\n && set -x \\\n && which asm2wasm \\\n && which llvm-ar \\\n && which emsdk \\\n && node --version \\\n && npm --version \\\n && python --version \\\n && pip --version \\\n && em++ --version \\\n && emcc --version \\\n && find ${EMSDK} -name \"*.pyc\" -exec rm {}\nRUN echo \"## Internal Testing of image (no activation)\" \\\n && set -x \\\n && which asm2wasm \\\n && which llvm-ar \\\n && which emsdk \\\n && node --version \\\n && npm --version \\\n && python --version \\\n && pip --version \\\n && em++ --version \\\n && emcc --version \\\n && find ${EMSDK} -name \"*.pyc\" -exec rm {}\n#   ------------------------------------------------------------------------------\n","originalDockerfileUglifiedHash":"3bbeaaff5b128e22429c519d3773e8ce","fileName":"/ICSME-replicationpackage/dataset/smelly_dockerfiles_bianncle/c20eba67cfa856fc15e0f6a76adda11e86461625.dockerfile"}