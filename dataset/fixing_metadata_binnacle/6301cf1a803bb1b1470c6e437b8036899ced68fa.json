{"seed":295391623,"processedDockerfileHash":"a369cac9d51e43c850294921cdb8151f","fixedSmells":["use-no-install-recommends","do-not-use-apt-get-update-alone","pin-package-manager-versions-apt-get","pin-package-manager-versions-pip","pin-package-manager-versions-npm","pin-package-manager-versions-gem","pin-package-manager-versions-apk","use-copy-instead-of-add","use-wget-instead-of-add","do-not-have-secrets","have-a-healthcheck","have-a-user"],"successfullyFixedSmells":["use-no-install-recommends","use-copy-instead-of-add","have-a-healthcheck"],"processedDockerfile":"#   Docker version 1.11.1\n#\n#   Line blocks used for commenting start with a #.\n#\n#   Default syntax is:\n#   INSTRUCTION arguments\n#\n#   INSTRUCTIONs are executed by order.\n#   FROM\n#\n#   It defines the base image to use to start the build process.\n#   It can be any image.\n#   If a FROM image is not found on the host, docker will try to find it (and download) from the docker image index.\n#   It needs to be the first command declared inside a Dockerfile.\n#\n#   Usage: FROM <image_name>:<tag>\n#   Usage: FROM <image>@<digest>\nFROM ubuntu:15.10\n#   MAINTAINER\n#\n#   It can be set anywhere in the file.\n#   This non-executing command declares the author of the image.\n#   It should come nonetheless after FROM.\n#\n#   Usage: MAINTAINER <name and/or email>\nMAINTAINER TheodorosPloumis <me@theodorosploumis.com>\n#   ENV\n#\n#   The ENV command is used to set the environment variables (one or more).\n#   These variables consist of “key = value” pairs which can be accessed within the container by scripts and applications alike.\n#   Unlike an ARG instruction, ENV values are always persisted in the built image.\n#   We can use ENV variables using $VARIABLE for substitution.\n#\n#   Usage: ENV key1 value1 key2 value2\n#   Usage: ENV key1=value1 key2=value2\n#   Usage with run: \"docker run --env <key>=<value>\"\nENV MEMORY=\"256M\"\n#   ARG\n#\n#   The ARG instruction defines a variable that users can pass at build-time to the builder\n#   with the docker build command using the --build-arg <varname>=<value> flag.\n#   If an ARG value has a default and if there is no value passed at build-time, the builder uses the default.\n#   Environment variables defined using the ENV instruction always override an ARG instruction of the same name.\n#   Docker has a set of predefined ARG variables that you can use without a corresponding ARG instruction in the Dockerfile.\n#   Such as: HTTP_PROXY, HTTPS_PROXY, FTP_PROXY, NO_PROXY\n#\n#   Usage: ARG <name>[=<default_value>]\n#   Usage with run: \"docker run --build-arg <arg_name>=<value>\"\nARG PRESENTATION_NAME=\"Docker for Developers\"\n#   LABEL\n#\n#   The LABEL instruction adds metadata to an image.\n#   A LABEL is a key-value pair.\n#   To include spaces within a LABEL value, use quotes and backslashes as you would in cli parsing.\n#\n#   Usage: LABEL key1 value1 key2 value2\n#   Usage: LABEL key1=value1 key2=value2\n#   Usage on the agent CLI: \"docker run --label <key>=<value>\"\nLABEL version=\"1.0\"\n#   ADD\n#\n#   The ADD command gets two arguments: a source and a destination.\n#   It copies the files from the source on the host into the container's own filesystem at the set destination.\n#   If, however, the source is a URL (e.g. http://github.com/user/file/), then the contents of the URL are downloaded and placed at the destination.\n#\n#   Usage: ADD <source_directory or URL> <destination_directory>\nCOPY /add-local-folder /added-container-folder\n#   STOPSIGNAL\n#\n#   The STOPSIGNAL instruction sets the system call signal that will be sent to the container to exit.\n#   This signal can be a valid unsigned number that matches a position in the kernel’s syscall table,\n#   for instance 9, or a signal name in the format SIGNAME, for instance SIGKILL.\n#   Usage: STOPSIGNAL <value>\nSTOPSIGNAL SIGTERM\n#   EXPOSE\n#\n#   The EXPOSE instruction informs Docker that the container listens on the specified network ports at runtime.\n#   EXPOSE does not make the ports of the container accessible to the host.\n#   To do that, you must use either the -p flag to publish a range of ports or the -P flag to publish all of the exposed ports.\n#   You can expose one port number and publish it externally under another number.\n#   To set up port redirection on the host system, see using the -P flag.\n#\n#   Usage: EXPOSE <port1> <port2> ...\nEXPOSE 80/tcp 3306/tcp\n#   COPY\n#\n#   The COPY instruction copies new files or directories from <src> and\n#   adds them to the filesystem of the container at the path <dest>.\n#   Multiple <src> resource may be specified but they must be relative to the source directory\n#   that is being built (the context of the build).\n#   Each <src> may contain wildcards.\n#\n#   Usahe: COPY <src>... <dest>\n#   Usage: COPY [\"<src>\",... \"<dest>\"] (this form is required for paths containing whitespace)\nCOPY copy-local-folder /copied-container-folder\n#   USER\n#\n#   The USER instruction sets the USER name or UID to use when running the image and for\n#   any RUN, CMD and ENTRYPOINT instructions that follow it in the Dockerfile.\n#\n#   Usage: USER <UID or USER_NAME>\nUSER 1000\n#   RUN\n#\n#   The RUN instruction will execute any commands in a new layer on top of the current image\n#   and commit the results, much like source control.\n#   The resulting committed image will be used for the next step in the Dockerfile.\n#\n#   Usage: RUN <command> (shell form, the command is run in a shell - /bin/sh -c)\n#   Usage: RUN [\"executable\", \"param1\", \"param2\"] (exec form)\nRUN apt-get update \\\n && apt-get install --no-install-recommends vim\n#   ONBUILD\n#\n#   The ONBUILD instruction adds to the image a trigger instruction to be executed at a later time,\n#   when the image is used as the base for another build.\n#   The trigger will be executed in the context of the downstream build,\n#   as if it had been inserted immediately after the FROM instruction in the downstream Dockerfile.\n#   Triggers are cleared from the final image after being executed (not inherited by \"grand-children\" builds).\n#\n#   Usage: ONBUILD [INSTRUCTION]\nONBUILD RUN echo \"This is ONBUILD.\"\n#   VOLUME\n#\n#   The VOLUME instruction creates a mount point with the specified name and\n#   marks it as holding externally mounted volumes from native host or other containers.\n#   The value can be a JSON array, VOLUME [\"/var/log/\"], or a plain string with multiple arguments, \n#   such as VOLUME /var/log or VOLUME /var/log /var/db.\n#   Paths can be ralative (to WORKDIR) or absolute.\n#   Anything after the VOLUME instruction in a Dockerfile will not be able to make changes to that volume.\n#   Data volumes are initialized when a container is created.\n#   Data volumes can be shared and reused among containers.\n#   Changes to a data volume are made directly.\n#   Changes to a data volume will not be included when you update an image.\n#   Data volumes persist even if the container itself is deleted.\n#\n#   Usage: VOLUME [\"/dir_1\", \"/dir_2\", ...]\n#   Usage: VOLUME /dir_1, /dir_2, ...\nVOLUME /added-container-folder /copied-container-folder\n#   WORKDIR\n#\n#   The WORKDIR instruction sets the working directory for any\n#   RUN, CMD, ENTRYPOINT, COPY and ADD instructions that follow it in the Dockerfile.\n#   It can be used multiple times in the one Dockerfile.\n#   If a relative path is provided, it will be relative to the path of the previous WORKDIR instruction.\n#\n#   Usage: WORKDIR /path/on/container\nWORKDIR /var/www/html\n#   ENTRYPOINT\n#\n#   An ENTRYPOINT allows you to configure a container that will run as an executable.\n#   Command line arguments to docker run <image> will be appended after all elements in an exec form ENTRYPOINT,\n#   and will override all elements specified using CMD.\n#   You can override the ENTRYPOINT instruction using the \"docker run --entrypoint <command>\" flag.\n#   Only the last ENTRYPOINT instruction in the Dockerfile will have an effect.\n#   The default ENTRYPOINT is /bin/sh -c and CMD is passed into that as an argument.\n#\n#   Usage: ENTRYPOINT [\"executable\", \"param1\", \"param2\"] #(exec form, preferred)\n#   Usage: ENTRYPOINT command param1 param2 #(shell form)\nENTRYPOINT [\"top\", \"-b\"]\n#   CMD\n#\n#   There can only be one CMD instruction in a Dockerfile!\n#   If you list more than one CMD then only the last CMD will take effect.\n#   The main purpose of a CMD is to provide defaults for an executing container.\n#   These defaults can include an executable, or they can omit the executable,\n#   in which case you must specify an ENTRYPOINT instruction as well.\n#\n#   Usage: CMD [\"executable\",\"param1\",\"param2\"] #(exec form, this is the preferred form)\n#   Usege: CMD [\"param1\",\"param2\"] #(as default parameters to ENTRYPOINT)\n#   Usage: CMD command param1 param2 #(shell form)\nCMD ls\n# Please add your HEALTHCHECK here!!!\n","originalDockerfile":"#  Docker version 1.11.1\n#\n#  Line blocks used for commenting start with a #.\n#\n#  Default syntax is:\n#  INSTRUCTION arguments\n#\n#  INSTRUCTIONs are executed by order.\n#  FROM\n#\n#  It defines the base image to use to start the build process.\n#  It can be any image.\n#  If a FROM image is not found on the host, docker will try to find it (and download) from the docker image index.\n#  It needs to be the first command declared inside a Dockerfile.\n#\n#  Usage: FROM <image_name>:<tag>\n#  Usage: FROM <image>@<digest>\nFROM ubuntu:15.10\n#  MAINTAINER\n#\n#  It can be set anywhere in the file.\n#  This non-executing command declares the author of the image.\n#  It should come nonetheless after FROM.\n#\n#  Usage: MAINTAINER <name and/or email>\nMAINTAINER TheodorosPloumis <me@theodorosploumis.com>\n#  ENV\n#\n#  The ENV command is used to set the environment variables (one or more).\n#  These variables consist of “key = value” pairs which can be accessed within the container by scripts and applications alike.\n#  Unlike an ARG instruction, ENV values are always persisted in the built image.\n#  We can use ENV variables using $VARIABLE for substitution.\n#\n#  Usage: ENV key1 value1 key2 value2\n#  Usage: ENV key1=value1 key2=value2\n#  Usage with run: \"docker run --env <key>=<value>\"\nENV MEMORY=\"256M\"\n#  ARG\n#\n#  The ARG instruction defines a variable that users can pass at build-time to the builder\n#  with the docker build command using the --build-arg <varname>=<value> flag.\n#  If an ARG value has a default and if there is no value passed at build-time, the builder uses the default.\n#  Environment variables defined using the ENV instruction always override an ARG instruction of the same name.\n#  Docker has a set of predefined ARG variables that you can use without a corresponding ARG instruction in the Dockerfile.\n#  Such as: HTTP_PROXY, HTTPS_PROXY, FTP_PROXY, NO_PROXY\n#\n#  Usage: ARG <name>[=<default_value>]\n#  Usage with run: \"docker run --build-arg <arg_name>=<value>\"\nARG PRESENTATION_NAME=\"Docker for Developers\"\n#  LABEL\n#\n#  The LABEL instruction adds metadata to an image.\n#  A LABEL is a key-value pair.\n#  To include spaces within a LABEL value, use quotes and backslashes as you would in cli parsing.\n#\n#  Usage: LABEL key1 value1 key2 value2\n#  Usage: LABEL key1=value1 key2=value2\n#  Usage on the agent CLI: \"docker run --label <key>=<value>\"\nLABEL version=\"1.0\"\n#  ADD\n#\n#  The ADD command gets two arguments: a source and a destination.\n#  It copies the files from the source on the host into the container's own filesystem at the set destination.\n#  If, however, the source is a URL (e.g. http://github.com/user/file/), then the contents of the URL are downloaded and placed at the destination.\n#\n#  Usage: ADD <source_directory or URL> <destination_directory>\nADD /add-local-folder /added-container-folder\n#  STOPSIGNAL\n#\n#  The STOPSIGNAL instruction sets the system call signal that will be sent to the container to exit.\n#  This signal can be a valid unsigned number that matches a position in the kernel’s syscall table,\n#  for instance 9, or a signal name in the format SIGNAME, for instance SIGKILL.\n#  Usage: STOPSIGNAL <value>\nSTOPSIGNAL SIGTERM\n#  EXPOSE\n#\n#  The EXPOSE instruction informs Docker that the container listens on the specified network ports at runtime.\n#  EXPOSE does not make the ports of the container accessible to the host.\n#  To do that, you must use either the -p flag to publish a range of ports or the -P flag to publish all of the exposed ports.\n#  You can expose one port number and publish it externally under another number.\n#  To set up port redirection on the host system, see using the -P flag.\n#\n#  Usage: EXPOSE <port1> <port2> ...\nEXPOSE 80/tcp 3306/tcp\n#  COPY\n#\n#  The COPY instruction copies new files or directories from <src> and\n#  adds them to the filesystem of the container at the path <dest>.\n#  Multiple <src> resource may be specified but they must be relative to the source directory\n#  that is being built (the context of the build).\n#  Each <src> may contain wildcards.\n#\n#  Usahe: COPY <src>... <dest>\n#  Usage: COPY [\"<src>\",... \"<dest>\"] (this form is required for paths containing whitespace)\nCOPY copy-local-folder /copied-container-folder\n#  USER\n#\n#  The USER instruction sets the USER name or UID to use when running the image and for\n#  any RUN, CMD and ENTRYPOINT instructions that follow it in the Dockerfile.\n#\n#  Usage: USER <UID or USER_NAME>\nUSER 1000\n#  RUN\n#\n#  The RUN instruction will execute any commands in a new layer on top of the current image\n#  and commit the results, much like source control.\n#  The resulting committed image will be used for the next step in the Dockerfile.\n#\n#  Usage: RUN <command> (shell form, the command is run in a shell - /bin/sh -c)\n#  Usage: RUN [\"executable\", \"param1\", \"param2\"] (exec form)\nRUN apt-get update \\\n && apt-get install vim\n#  ONBUILD\n#\n#  The ONBUILD instruction adds to the image a trigger instruction to be executed at a later time,\n#  when the image is used as the base for another build.\n#  The trigger will be executed in the context of the downstream build,\n#  as if it had been inserted immediately after the FROM instruction in the downstream Dockerfile.\n#  Triggers are cleared from the final image after being executed (not inherited by \"grand-children\" builds).\n#\n#  Usage: ONBUILD [INSTRUCTION]\nONBUILD RUN echo \"This is ONBUILD.\"\n#  VOLUME\n#\n#  The VOLUME instruction creates a mount point with the specified name and\n#  marks it as holding externally mounted volumes from native host or other containers.\n#  The value can be a JSON array, VOLUME [\"/var/log/\"], or a plain string with multiple arguments, \n#  such as VOLUME /var/log or VOLUME /var/log /var/db.\n#  Paths can be ralative (to WORKDIR) or absolute.\n#  Anything after the VOLUME instruction in a Dockerfile will not be able to make changes to that volume.\n#  Data volumes are initialized when a container is created.\n#  Data volumes can be shared and reused among containers.\n#  Changes to a data volume are made directly.\n#  Changes to a data volume will not be included when you update an image.\n#  Data volumes persist even if the container itself is deleted.\n#\n#  Usage: VOLUME [\"/dir_1\", \"/dir_2\", ...]\n#  Usage: VOLUME /dir_1, /dir_2, ...\nVOLUME /added-container-folder /copied-container-folder\n#  WORKDIR\n#\n#  The WORKDIR instruction sets the working directory for any\n#  RUN, CMD, ENTRYPOINT, COPY and ADD instructions that follow it in the Dockerfile.\n#  It can be used multiple times in the one Dockerfile.\n#  If a relative path is provided, it will be relative to the path of the previous WORKDIR instruction.\n#\n#  Usage: WORKDIR /path/on/container\nWORKDIR /var/www/html\n#  ENTRYPOINT\n#\n#  An ENTRYPOINT allows you to configure a container that will run as an executable.\n#  Command line arguments to docker run <image> will be appended after all elements in an exec form ENTRYPOINT,\n#  and will override all elements specified using CMD.\n#  You can override the ENTRYPOINT instruction using the \"docker run --entrypoint <command>\" flag.\n#  Only the last ENTRYPOINT instruction in the Dockerfile will have an effect.\n#  The default ENTRYPOINT is /bin/sh -c and CMD is passed into that as an argument.\n#\n#  Usage: ENTRYPOINT [\"executable\", \"param1\", \"param2\"] #(exec form, preferred)\n#  Usage: ENTRYPOINT command param1 param2 #(shell form)\nENTRYPOINT [\"top\", \"-b\"]\n#  CMD\n#\n#  There can only be one CMD instruction in a Dockerfile!\n#  If you list more than one CMD then only the last CMD will take effect.\n#  The main purpose of a CMD is to provide defaults for an executing container.\n#  These defaults can include an executable, or they can omit the executable,\n#  in which case you must specify an ENTRYPOINT instruction as well.\n#\n#  Usage: CMD [\"executable\",\"param1\",\"param2\"] #(exec form, this is the preferred form)\n#  Usege: CMD [\"param1\",\"param2\"] #(as default parameters to ENTRYPOINT)\n#  Usage: CMD command param1 param2 #(shell form)\nCMD ls\n","injectedSmells":[],"originalDockerfileHash":"090810b4786db225060a6cbd119b5187","successfullyInjectedSmells":[],"originalDockerfileUglified":"#   Docker version 1.11.1\n#\n#   Line blocks used for commenting start with a #.\n#\n#   Default syntax is:\n#   INSTRUCTION arguments\n#\n#   INSTRUCTIONs are executed by order.\n#   FROM\n#\n#   It defines the base image to use to start the build process.\n#   It can be any image.\n#   If a FROM image is not found on the host, docker will try to find it (and download) from the docker image index.\n#   It needs to be the first command declared inside a Dockerfile.\n#\n#   Usage: FROM <image_name>:<tag>\n#   Usage: FROM <image>@<digest>\nFROM ubuntu:15.10\n#   MAINTAINER\n#\n#   It can be set anywhere in the file.\n#   This non-executing command declares the author of the image.\n#   It should come nonetheless after FROM.\n#\n#   Usage: MAINTAINER <name and/or email>\nMAINTAINER TheodorosPloumis <me@theodorosploumis.com>\n#   ENV\n#\n#   The ENV command is used to set the environment variables (one or more).\n#   These variables consist of “key = value” pairs which can be accessed within the container by scripts and applications alike.\n#   Unlike an ARG instruction, ENV values are always persisted in the built image.\n#   We can use ENV variables using $VARIABLE for substitution.\n#\n#   Usage: ENV key1 value1 key2 value2\n#   Usage: ENV key1=value1 key2=value2\n#   Usage with run: \"docker run --env <key>=<value>\"\nENV MEMORY=\"256M\"\n#   ARG\n#\n#   The ARG instruction defines a variable that users can pass at build-time to the builder\n#   with the docker build command using the --build-arg <varname>=<value> flag.\n#   If an ARG value has a default and if there is no value passed at build-time, the builder uses the default.\n#   Environment variables defined using the ENV instruction always override an ARG instruction of the same name.\n#   Docker has a set of predefined ARG variables that you can use without a corresponding ARG instruction in the Dockerfile.\n#   Such as: HTTP_PROXY, HTTPS_PROXY, FTP_PROXY, NO_PROXY\n#\n#   Usage: ARG <name>[=<default_value>]\n#   Usage with run: \"docker run --build-arg <arg_name>=<value>\"\nARG PRESENTATION_NAME=\"Docker for Developers\"\n#   LABEL\n#\n#   The LABEL instruction adds metadata to an image.\n#   A LABEL is a key-value pair.\n#   To include spaces within a LABEL value, use quotes and backslashes as you would in cli parsing.\n#\n#   Usage: LABEL key1 value1 key2 value2\n#   Usage: LABEL key1=value1 key2=value2\n#   Usage on the agent CLI: \"docker run --label <key>=<value>\"\nLABEL version=\"1.0\"\n#   ADD\n#\n#   The ADD command gets two arguments: a source and a destination.\n#   It copies the files from the source on the host into the container's own filesystem at the set destination.\n#   If, however, the source is a URL (e.g. http://github.com/user/file/), then the contents of the URL are downloaded and placed at the destination.\n#\n#   Usage: ADD <source_directory or URL> <destination_directory>\nADD /add-local-folder /added-container-folder\n#   STOPSIGNAL\n#\n#   The STOPSIGNAL instruction sets the system call signal that will be sent to the container to exit.\n#   This signal can be a valid unsigned number that matches a position in the kernel’s syscall table,\n#   for instance 9, or a signal name in the format SIGNAME, for instance SIGKILL.\n#   Usage: STOPSIGNAL <value>\nSTOPSIGNAL SIGTERM\n#   EXPOSE\n#\n#   The EXPOSE instruction informs Docker that the container listens on the specified network ports at runtime.\n#   EXPOSE does not make the ports of the container accessible to the host.\n#   To do that, you must use either the -p flag to publish a range of ports or the -P flag to publish all of the exposed ports.\n#   You can expose one port number and publish it externally under another number.\n#   To set up port redirection on the host system, see using the -P flag.\n#\n#   Usage: EXPOSE <port1> <port2> ...\nEXPOSE 80/tcp 3306/tcp\n#   COPY\n#\n#   The COPY instruction copies new files or directories from <src> and\n#   adds them to the filesystem of the container at the path <dest>.\n#   Multiple <src> resource may be specified but they must be relative to the source directory\n#   that is being built (the context of the build).\n#   Each <src> may contain wildcards.\n#\n#   Usahe: COPY <src>... <dest>\n#   Usage: COPY [\"<src>\",... \"<dest>\"] (this form is required for paths containing whitespace)\nCOPY copy-local-folder /copied-container-folder\n#   USER\n#\n#   The USER instruction sets the USER name or UID to use when running the image and for\n#   any RUN, CMD and ENTRYPOINT instructions that follow it in the Dockerfile.\n#\n#   Usage: USER <UID or USER_NAME>\nUSER 1000\n#   RUN\n#\n#   The RUN instruction will execute any commands in a new layer on top of the current image\n#   and commit the results, much like source control.\n#   The resulting committed image will be used for the next step in the Dockerfile.\n#\n#   Usage: RUN <command> (shell form, the command is run in a shell - /bin/sh -c)\n#   Usage: RUN [\"executable\", \"param1\", \"param2\"] (exec form)\nRUN apt-get update \\\n && apt-get install vim\n#   ONBUILD\n#\n#   The ONBUILD instruction adds to the image a trigger instruction to be executed at a later time,\n#   when the image is used as the base for another build.\n#   The trigger will be executed in the context of the downstream build,\n#   as if it had been inserted immediately after the FROM instruction in the downstream Dockerfile.\n#   Triggers are cleared from the final image after being executed (not inherited by \"grand-children\" builds).\n#\n#   Usage: ONBUILD [INSTRUCTION]\nONBUILD RUN echo \"This is ONBUILD.\"\n#   VOLUME\n#\n#   The VOLUME instruction creates a mount point with the specified name and\n#   marks it as holding externally mounted volumes from native host or other containers.\n#   The value can be a JSON array, VOLUME [\"/var/log/\"], or a plain string with multiple arguments, \n#   such as VOLUME /var/log or VOLUME /var/log /var/db.\n#   Paths can be ralative (to WORKDIR) or absolute.\n#   Anything after the VOLUME instruction in a Dockerfile will not be able to make changes to that volume.\n#   Data volumes are initialized when a container is created.\n#   Data volumes can be shared and reused among containers.\n#   Changes to a data volume are made directly.\n#   Changes to a data volume will not be included when you update an image.\n#   Data volumes persist even if the container itself is deleted.\n#\n#   Usage: VOLUME [\"/dir_1\", \"/dir_2\", ...]\n#   Usage: VOLUME /dir_1, /dir_2, ...\nVOLUME /added-container-folder /copied-container-folder\n#   WORKDIR\n#\n#   The WORKDIR instruction sets the working directory for any\n#   RUN, CMD, ENTRYPOINT, COPY and ADD instructions that follow it in the Dockerfile.\n#   It can be used multiple times in the one Dockerfile.\n#   If a relative path is provided, it will be relative to the path of the previous WORKDIR instruction.\n#\n#   Usage: WORKDIR /path/on/container\nWORKDIR /var/www/html\n#   ENTRYPOINT\n#\n#   An ENTRYPOINT allows you to configure a container that will run as an executable.\n#   Command line arguments to docker run <image> will be appended after all elements in an exec form ENTRYPOINT,\n#   and will override all elements specified using CMD.\n#   You can override the ENTRYPOINT instruction using the \"docker run --entrypoint <command>\" flag.\n#   Only the last ENTRYPOINT instruction in the Dockerfile will have an effect.\n#   The default ENTRYPOINT is /bin/sh -c and CMD is passed into that as an argument.\n#\n#   Usage: ENTRYPOINT [\"executable\", \"param1\", \"param2\"] #(exec form, preferred)\n#   Usage: ENTRYPOINT command param1 param2 #(shell form)\nENTRYPOINT [\"top\", \"-b\"]\n#   CMD\n#\n#   There can only be one CMD instruction in a Dockerfile!\n#   If you list more than one CMD then only the last CMD will take effect.\n#   The main purpose of a CMD is to provide defaults for an executing container.\n#   These defaults can include an executable, or they can omit the executable,\n#   in which case you must specify an ENTRYPOINT instruction as well.\n#\n#   Usage: CMD [\"executable\",\"param1\",\"param2\"] #(exec form, this is the preferred form)\n#   Usege: CMD [\"param1\",\"param2\"] #(as default parameters to ENTRYPOINT)\n#   Usage: CMD command param1 param2 #(shell form)\nCMD ls\n","originalDockerfileUglifiedHash":"7650be54b3fb7711e0895320d216f3e6","fileName":"/ICSME-replicationpackage/dataset/smelly_dockerfiles_bianncle/6301cf1a803bb1b1470c6e437b8036899ced68fa.dockerfile"}