{"seed":2951538574,"processedDockerfileHash":"9f0c3e87ae2f2880ae5aafb8f3fef7f1","fixedSmells":["pin-package-manager-versions-apk","have-a-user"],"successfullyFixedSmells":["pin-package-manager-versions-apk","have-a-user"],"processedDockerfile":"FROM alpine:3.14\n#   This is the release of Vault to pull in.\nARG VAULT_VERSION=1.9.3\nSHELL [\"/bin/ash\", \"-o\", \"pipefail\", \"-c\"]\n#   Create a vault user and group first so the IDs get set the same way,\n#   even as the rest of this may change over time.\nRUN addgroup vault \\\n && adduser -S -G vault vault\n#   Set up certificates, our base tools, and Vault.\nRUN set -eux ; apk add ca-certificates=20220614-r0 gnupg=2.2.31-r1 openssl=1.1.1t-r2 libcap=2.50-r0 su-exec=0.2-r1 dumb-init=1.2.5-r1 tzdata=2023c-r0 --no-cache \\\n && apkArch=\"$( apk --print-arch ;)\" ; case \"$apkArch\" in (armhf) ARCH='arm' ;;(aarch64) ARCH='arm64' ;;(x86_64) ARCH='amd64' ;;(x86) ARCH='386' ;;(*) echo \"error: unsupported architecture: $apkArch\" >&2; exit 1 ;; esac \\\n && VAULT_GPGKEY=C874011F0AB405110D02105534365D9472D7468F ; found='' ; for server in hkp://p80.pool.sks-keyservers.net:80 hkp://keyserver.ubuntu.com:80 hkp://pgp.mit.edu:80; do echo \"Fetching GPG key $VAULT_GPGKEY from $server\" ;gpg --batch --keyserver \"$server\" --recv-keys \"$VAULT_GPGKEY\" \\\n && found=yes \\\n && break ; done ; test -z \"$found\" \\\n && echo \"error: failed to fetch GPG key $VAULT_GPGKEY\" >&2 \\\n && exit 1 ; mkdir -p /tmp/build \\\n && cd /tmp/build \\\n && wget -nv https://releases.hashicorp.com/vault/${VAULT_VERSION}/vault_${VAULT_VERSION}_linux_${ARCH}.zip \\\n && wget -nv https://releases.hashicorp.com/vault/${VAULT_VERSION}/vault_${VAULT_VERSION}_SHA256SUMS \\\n && wget -nv https://releases.hashicorp.com/vault/${VAULT_VERSION}/vault_${VAULT_VERSION}_SHA256SUMS.sig \\\n && gpg --batch --verify vault_${VAULT_VERSION}_SHA256SUMS.sig vault_${VAULT_VERSION}_SHA256SUMS \\\n && grep vault_${VAULT_VERSION}_linux_${ARCH}.zip vault_${VAULT_VERSION}_SHA256SUMS | sha256sum -c \\\n && unzip -d /tmp/build vault_${VAULT_VERSION}_linux_${ARCH}.zip \\\n && cp /tmp/build/vault /bin/vault \\\n && if [ -f /tmp/build/EULA.txt ] ; then mkdir -p /usr/share/doc/vault ;mv /tmp/build/EULA.txt /usr/share/doc/vault/EULA.txt ; fi \\\n && if [ -f /tmp/build/TermsOfEvaluation.txt ] ; then mkdir -p /usr/share/doc/vault ;mv /tmp/build/TermsOfEvaluation.txt /usr/share/doc/vault/TermsOfEvaluation.txt ; fi \\\n && cd /tmp \\\n && rm -rf /tmp/build \\\n && gpgconf --kill dirmngr \\\n && gpgconf --kill gpg-agent \\\n && apk del gnupg openssl \\\n && rm -rf /root/.gnupg\n#   /vault/logs is made available to use as a location to store audit logs, if\n#   desired; /vault/file is made available to use as a location with the file\n#   storage backend, if desired; the server will be started with /vault/config as\n#   the configuration directory so you can add additional config files in that\n#   location.\nRUN mkdir -p /vault/logs \\\n && mkdir -p /vault/file \\\n && mkdir -p /vault/config \\\n && chown -R vault:vault /vault\n#   Expose the logs directory as a volume since there's potentially long-running\n#   state in there\nVOLUME /vault/logs\n#   Expose the file directory as a volume since there's potentially long-running\n#   state in there\nVOLUME /vault/file\n#   8200/tcp is the primary interface that applications use to interact with\n#   Vault.\nEXPOSE 8200/tcp\n#   The entry point script uses dumb-init as the top-level process to reap any\n#   zombie processes created by Vault sub-processes.\n#\n#   For production derivatives of this container, you shoud add the IPC_LOCK\n#   capability so that Vault can mlock memory.\nCOPY docker-entrypoint.sh /usr/local/bin/docker-entrypoint.sh\nENTRYPOINT [\"docker-entrypoint.sh\"]\nHEALTHCHECK CMD curl --fail http://127.0.0.1:8200 || exit 1\n#   By default you'll get a single-node development server that stores everything\n#   in RAM and bootstraps itself. Don't use this configuration for production.\nCMD [\"server\", \"-dev\"]\nUSER 0:m936d30bq42n_sf\nRUN addgroup -S docker-user ; adduser -S -G docker-user docker-user\nUSER docker-user\n","originalDockerfile":"FROM alpine:3.14\n#  This is the release of Vault to pull in.\nARG VAULT_VERSION=1.9.3\nSHELL [\"/bin/ash\", \"-o\", \"pipefail\", \"-c\"]\n#  Create a vault user and group first so the IDs get set the same way,\n#  even as the rest of this may change over time.\nRUN addgroup vault \\\n && adduser -S -G vault vault\n#  Set up certificates, our base tools, and Vault.\nRUN set -eux ; apk add ca-certificates gnupg openssl libcap su-exec dumb-init tzdata --no-cache \\\n && apkArch=\"$( apk --print-arch ;)\" ; case \"$apkArch\" in (armhf) ARCH='arm' ;;(aarch64) ARCH='arm64' ;;(x86_64) ARCH='amd64' ;;(x86) ARCH='386' ;;(*) echo \"error: unsupported architecture: $apkArch\" >&2; exit 1 ;; esac \\\n && VAULT_GPGKEY=C874011F0AB405110D02105534365D9472D7468F ; found='' ; for server in hkp://p80.pool.sks-keyservers.net:80 hkp://keyserver.ubuntu.com:80 hkp://pgp.mit.edu:80; do echo \"Fetching GPG key $VAULT_GPGKEY from $server\" ;gpg --batch --keyserver \"$server\" --recv-keys \"$VAULT_GPGKEY\" \\\n && found=yes \\\n && break ; done ; test -z \"$found\" \\\n && echo \"error: failed to fetch GPG key $VAULT_GPGKEY\" >&2 \\\n && exit 1 ; mkdir -p /tmp/build \\\n && cd /tmp/build \\\n && wget -nv https://releases.hashicorp.com/vault/${VAULT_VERSION}/vault_${VAULT_VERSION}_linux_${ARCH}.zip \\\n && wget -nv https://releases.hashicorp.com/vault/${VAULT_VERSION}/vault_${VAULT_VERSION}_SHA256SUMS \\\n && wget -nv https://releases.hashicorp.com/vault/${VAULT_VERSION}/vault_${VAULT_VERSION}_SHA256SUMS.sig \\\n && gpg --batch --verify vault_${VAULT_VERSION}_SHA256SUMS.sig vault_${VAULT_VERSION}_SHA256SUMS \\\n && grep vault_${VAULT_VERSION}_linux_${ARCH}.zip vault_${VAULT_VERSION}_SHA256SUMS | sha256sum -c \\\n && unzip -d /tmp/build vault_${VAULT_VERSION}_linux_${ARCH}.zip \\\n && cp /tmp/build/vault /bin/vault \\\n && if [ -f /tmp/build/EULA.txt ] ; then mkdir -p /usr/share/doc/vault ;mv /tmp/build/EULA.txt /usr/share/doc/vault/EULA.txt ; fi \\\n && if [ -f /tmp/build/TermsOfEvaluation.txt ] ; then mkdir -p /usr/share/doc/vault ;mv /tmp/build/TermsOfEvaluation.txt /usr/share/doc/vault/TermsOfEvaluation.txt ; fi \\\n && cd /tmp \\\n && rm -rf /tmp/build \\\n && gpgconf --kill dirmngr \\\n && gpgconf --kill gpg-agent \\\n && apk del gnupg openssl \\\n && rm -rf /root/.gnupg\n#  /vault/logs is made available to use as a location to store audit logs, if\n#  desired; /vault/file is made available to use as a location with the file\n#  storage backend, if desired; the server will be started with /vault/config as\n#  the configuration directory so you can add additional config files in that\n#  location.\nRUN mkdir -p /vault/logs \\\n && mkdir -p /vault/file \\\n && mkdir -p /vault/config \\\n && chown -R vault:vault /vault\n#  Expose the logs directory as a volume since there's potentially long-running\n#  state in there\nVOLUME /vault/logs\n#  Expose the file directory as a volume since there's potentially long-running\n#  state in there\nVOLUME /vault/file\n#  8200/tcp is the primary interface that applications use to interact with\n#  Vault.\nEXPOSE 8200/tcp\n#  The entry point script uses dumb-init as the top-level process to reap any\n#  zombie processes created by Vault sub-processes.\n#\n#  For production derivatives of this container, you shoud add the IPC_LOCK\n#  capability so that Vault can mlock memory.\nCOPY docker-entrypoint.sh /usr/local/bin/docker-entrypoint.sh\nENTRYPOINT [\"docker-entrypoint.sh\"]\nHEALTHCHECK CMD curl --fail http://127.0.0.1:8200 || exit 1\n#  By default you'll get a single-node development server that stores everything\n#  in RAM and bootstraps itself. Don't use this configuration for production.\nCMD [\"server\", \"-dev\"]\nUSER 0:m936d30bq42n_sf\n","injectedSmells":[],"originalDockerfileHash":"b4bd682470f274e3647f8053afece78e","successfullyInjectedSmells":[],"originalDockerfileUglified":"FROM alpine:3.14\n#   This is the release of Vault to pull in.\nARG VAULT_VERSION=1.9.3\nSHELL [\"/bin/ash\", \"-o\", \"pipefail\", \"-c\"]\n#   Create a vault user and group first so the IDs get set the same way,\n#   even as the rest of this may change over time.\nRUN addgroup vault \\\n && adduser -S -G vault vault\n#   Set up certificates, our base tools, and Vault.\nRUN set -eux ; apk add ca-certificates gnupg openssl libcap su-exec dumb-init tzdata --no-cache \\\n && apkArch=\"$( apk --print-arch ;)\" ; case \"$apkArch\" in (armhf) ARCH='arm' ;;(aarch64) ARCH='arm64' ;;(x86_64) ARCH='amd64' ;;(x86) ARCH='386' ;;(*) echo \"error: unsupported architecture: $apkArch\" >&2; exit 1 ;; esac \\\n && VAULT_GPGKEY=C874011F0AB405110D02105534365D9472D7468F ; found='' ; for server in hkp://p80.pool.sks-keyservers.net:80 hkp://keyserver.ubuntu.com:80 hkp://pgp.mit.edu:80; do echo \"Fetching GPG key $VAULT_GPGKEY from $server\" ;gpg --batch --keyserver \"$server\" --recv-keys \"$VAULT_GPGKEY\" \\\n && found=yes \\\n && break ; done ; test -z \"$found\" \\\n && echo \"error: failed to fetch GPG key $VAULT_GPGKEY\" >&2 \\\n && exit 1 ; mkdir -p /tmp/build \\\n && cd /tmp/build \\\n && wget -nv https://releases.hashicorp.com/vault/${VAULT_VERSION}/vault_${VAULT_VERSION}_linux_${ARCH}.zip \\\n && wget -nv https://releases.hashicorp.com/vault/${VAULT_VERSION}/vault_${VAULT_VERSION}_SHA256SUMS \\\n && wget -nv https://releases.hashicorp.com/vault/${VAULT_VERSION}/vault_${VAULT_VERSION}_SHA256SUMS.sig \\\n && gpg --batch --verify vault_${VAULT_VERSION}_SHA256SUMS.sig vault_${VAULT_VERSION}_SHA256SUMS \\\n && grep vault_${VAULT_VERSION}_linux_${ARCH}.zip vault_${VAULT_VERSION}_SHA256SUMS | sha256sum -c \\\n && unzip -d /tmp/build vault_${VAULT_VERSION}_linux_${ARCH}.zip \\\n && cp /tmp/build/vault /bin/vault \\\n && if [ -f /tmp/build/EULA.txt ] ; then mkdir -p /usr/share/doc/vault ;mv /tmp/build/EULA.txt /usr/share/doc/vault/EULA.txt ; fi \\\n && if [ -f /tmp/build/TermsOfEvaluation.txt ] ; then mkdir -p /usr/share/doc/vault ;mv /tmp/build/TermsOfEvaluation.txt /usr/share/doc/vault/TermsOfEvaluation.txt ; fi \\\n && cd /tmp \\\n && rm -rf /tmp/build \\\n && gpgconf --kill dirmngr \\\n && gpgconf --kill gpg-agent \\\n && apk del gnupg openssl \\\n && rm -rf /root/.gnupg\n#   /vault/logs is made available to use as a location to store audit logs, if\n#   desired; /vault/file is made available to use as a location with the file\n#   storage backend, if desired; the server will be started with /vault/config as\n#   the configuration directory so you can add additional config files in that\n#   location.\nRUN mkdir -p /vault/logs \\\n && mkdir -p /vault/file \\\n && mkdir -p /vault/config \\\n && chown -R vault:vault /vault\n#   Expose the logs directory as a volume since there's potentially long-running\n#   state in there\nVOLUME /vault/logs\n#   Expose the file directory as a volume since there's potentially long-running\n#   state in there\nVOLUME /vault/file\n#   8200/tcp is the primary interface that applications use to interact with\n#   Vault.\nEXPOSE 8200/tcp\n#   The entry point script uses dumb-init as the top-level process to reap any\n#   zombie processes created by Vault sub-processes.\n#\n#   For production derivatives of this container, you shoud add the IPC_LOCK\n#   capability so that Vault can mlock memory.\nCOPY docker-entrypoint.sh /usr/local/bin/docker-entrypoint.sh\nENTRYPOINT [\"docker-entrypoint.sh\"]\nHEALTHCHECK CMD curl --fail http://127.0.0.1:8200 || exit 1\n#   By default you'll get a single-node development server that stores everything\n#   in RAM and bootstraps itself. Don't use this configuration for production.\nCMD [\"server\", \"-dev\"]\nUSER 0:m936d30bq42n_sf\n","originalDockerfileUglifiedHash":"01c4b12a9e708cbcc8a61f6e8c79b2a4","fileName":"/ICSME-replicationpackage/dataset/smelly_dockerfiles/vault__1.9.3__4__injected.dockerfile"}